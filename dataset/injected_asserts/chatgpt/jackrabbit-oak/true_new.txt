assertEquals ( "msg" , ex . getMessage ( ) )
assertEquals ( base . toString ( ) , ex . getMessage ( ) )
assertEquals ( "ExternalIdentityRef{" + "id='" + r . getId ( ) + '\'' + ", providerName='" + r . getProviderName ( ) + '\'' + '}' , r . toString ( ) )
assertNull ( getUserManager ( root ) . getAuthorizable ( id ) )
assertTrue ( a . hasProperty ( ExternalIdentityConstants . REP_LAST_SYNCED ) )
assertNull ( userManager . getAuthorizable ( USER_ID ) )
assertEquals ( UserConstants . DEFAULT_ANONYMOUS_ID , cs . getAuthInfo ( ) . getUserID ( ) )
assertNull ( DefaultSyncContext . createSyncedIdentity ( null ) )
assertEquals ( SyncResult . Status . ADD , result . getStatus ( ) )
assertNull ( syncCtx . getExternalGroupFromRef ( new ExternalIdentityRef ( TestIdentityProvider . ID_EXCEPTION , idp . getName ( ) ) ) )
assertNull ( syncCtx . getExternalGroupFromRef ( user . getExternalId ( ) ) )
assertFalse ( a . hasProperty ( propName ) )
assertFalse ( a . hasProperty ( propName ) )
assertFalse ( syncCtx . isSameIDP ( createTestGroup ( ) ) )
assertFalse ( syncCtx . isSameIDP ( getTestUser ( ) ) )
assertTrue ( syncCtx . isSameIDP ( userManager . getAuthorizable ( externalGroup . getId ( ) ) ) )
assertTrue ( syncCtx . isSameIDP ( userManager . getAuthorizable ( externalUser . getId ( ) ) ) )
assertNull ( res . getIdentity ( ) )
assertEquals ( si , new DefaultSyncResultImpl ( si , SyncResult . Status . NOP ) . getIdentity ( ) )
assertTrue ( AutoMembershipConfig . EMPTY . getName ( ) . isEmpty ( ) )
assertEquals ( "testUser" , info . getUserID ( ) )
assertEquals ( DefaultSyncConfigImpl . PARAM_NAME_DEFAULT , config . getName ( ) )
assertEquals ( ImmutableMap . of ( "valid" , "mapping" , "valid2" , "mapping" ) , userConfig . getPropertyMapping ( ) )
assertEquals ( syncConfig . getName ( ) , syncHandler . getName ( ) )
assertTrue ( t . hasProperty ( REP_EXTERNAL_PRINCIPAL_NAMES ) )
assertNotNull ( a )
assertFalse ( t . hasProperty ( REP_EXTERNAL_PRINCIPAL_NAMES ) )
assertTrue ( t . hasProperty ( REP_EXTERNAL_PRINCIPAL_NAMES ) )
assertNull ( f . get ( factory ) )
assertNull ( f . get ( factory ) )
assertEquals ( "invalid" , syncMBean . getSyncHandlerName ( ) )
assertNotNull ( getUserManager ( ) . getAuthorizable ( UserConstants . DEFAULT_ANONYMOUS_ID ) )
assertEquals ( 0 , result . length )
assertTrue ( monitor . getMonitorProperties ( ) . isEmpty ( ) )
assertTrue ( amp . getAutoMembership ( "unknown" , authorizable , false ) . isEmpty ( ) )
assertTrue ( amprincipals . getAutoMembership ( IDP_VALID_AM , authorizable , false ) . isEmpty ( ) )
assertFalse ( provider . isMember ( automembershipGroup1 , getTestUser ( ) , false ) )
assertFalse ( amp . getMembership ( getTestUser ( ) , false ) . hasNext ( ) )
assertFalse ( amp . getMembership ( getTestUser ( ) , false ) . hasNext ( ) )
assertTrue ( DynamicGroupUtil . getInheritedPrincipals ( new PrincipalImpl ( "test" ) , um ) . isEmpty ( ) )
assertTrue ( DynamicGroupUtil . getInheritedPrincipals ( new PrincipalImpl ( "test" ) , um ) . isEmpty ( ) )
assertTrue ( validator instanceof SubtreeValidator )
assertEquals ( 77 , e . getCode ( ) )
assertEquals ( 77 , e . getCode ( ) )
assertNotNull ( getUserManager ( root ) . getAuthorizable ( ref . getId ( ) ) )
assertNotNull ( getUserManager ( root ) . getAuthorizable ( "thirdGroup" ) )
assertNotNull ( getUserManager ( root ) . getAuthorizable ( ref . getId ( ) ) )
assertNotNull ( getUserManager ( root ) . getAuthorizable ( id ) )
assertNull ( principalProvider . getPrincipal ( idp . getGroup ( "a" ) . getPrincipalName ( ) ) )
assertNull ( principalProvider . getPrincipal ( getTestUser ( ) . getPrincipal ( ) . getName ( ) ) )
assertNull ( principalProvider . getPrincipal ( n ) )
assertTrue ( principals . isEmpty ( ) )
assertTrue ( principalProvider . getMembershipPrincipals ( p ) . isEmpty ( ) )
assertTrue ( principals . isEmpty ( ) )
assertTrue ( principals . isEmpty ( ) )
assertTrue ( pp . getPrincipals ( USER_ID ) . isEmpty ( ) )
assertTrue ( principalNames . isEmpty ( ) )
assertTrue ( result . isEmpty ( ) )
assertTrue ( oakIndex . exists ( ) )
assertTrue ( oakIndex . exists ( ) )
assertEquals ( ! exceptionExpected ( ) , g . isMember ( getTestUser ( ) ) )
assertEquals ( ! exceptionExpected ( ) , root . getTree ( externalUserPath ) . hasProperty ( JCR_MIXINTYPES ) )
assertEquals ( exceptionExpected ( ) , root . getTree ( externalUserPath ) . exists ( ) )
assertTrue ( principalProvider . getMembershipPrincipals ( gp ) . isEmpty ( ) )
assertTrue ( Iterables . isEmpty ( tracker . getIdpNames ( "testSH" ) ) )
assertTrue ( Iterables . isEmpty ( tracker . getIdpNames ( "testSH" ) ) )
assertTrue ( Iterables . isEmpty ( tracker . getIdpNames ( "testSH" ) ) )
assertTrue ( Iterables . isEmpty ( tracker . getIdpNames ( "testSH" ) ) )
assertTrue ( Iterables . isEmpty ( tracker . getIdpNames ( "testSH" ) ) )
assertEquals ( UserConstants . DEFAULT_ANONYMOUS_ID , cs . getAuthInfo ( ) . getUserID ( ) )
assertEquals ( UserConstants . DEFAULT_ANONYMOUS_ID , cs . getAuthInfo ( ) . getUserID ( ) )
assertTrue ( "Group instance" , id instanceof ExternalGroup )
assertNull ( userManager . getAuthorizable ( USER_ID ) )
assertTrue ( props . isEmpty ( ) )
assertNull ( properties . put ( null , "value" ) )
assertEquals ( properties . get ( "a" ) , properties . get ( "A" ) )
assertEquals ( "id" , provider . fromExternalIdentityRef ( new ExternalIdentityRef ( "id" , provider . getName ( ) ) ) )
assertEquals ( expectedIds , ImmutableSet . copyOf ( ids ) )
assertNull ( "Unknown user must return null" , id )
assertNull ( group )
assertTrue ( "Group instance" , id instanceof ExternalGroup )
assertTrue ( Iterables . isEmpty ( memberrefs ) )
assertTrue ( "User instance" , id instanceof ExternalUser )
assertEquals ( ImmutableSet . copyOf ( TEST_USER1_GROUPS ) , ImmutableSet . copyOf ( groupIds ) )
assertEquals ( expectedIds , ImmutableSet . copyOf ( ids ) )
assertEquals ( LdapProviderConfig . PARAM_NAME_DEFAULT , config . getName ( ) )
assertEquals ( encodedValue , LdapProviderConfig . encodeFilterValue ( value ) )
assertEquals ( encodedValue , LdapProviderConfig . encodeFilterValue ( value ) )
assertTrue ( validator instanceof LookupLdapConnectionValidator )
assertTrue ( factory . wrap ( lc ) instanceof DefaultPooledObject )
assertFalse ( validator . validate ( connection ) )
assertFalse ( validator . validate ( connection ) )
assertNull ( "Foreign ref must be null" , id )
assertTrue ( "Group instance" , id instanceof ExternalGroup )
assertEquals ( Permissions . NO_PERMISSION , pp . supportedPermissions ( root . getTree ( acPath ) , null , Permissions . READ ) )
assertFalse ( pp . hasPrivileges ( root . getTree ( acPath ) , PrivilegeConstants . JCR_READ ) )
assertEquals ( 2 , effective . length )
assertFalse ( ntMgr . isNodeType ( root . getTree ( SUPPORTED_PATH ) , MIX_REP_CUG_MIXIN ) )
assertEquals ( 4 , acMgr . getEffectivePolicies ( ImmutableSet . of ( getTestGroupPrincipal ( ) , EveryonePrincipal . getInstance ( ) ) ) . length )
assertTrue ( permissionProvider instanceof CugPermissionProvider )
assertTrue ( permissionProvider instanceof CugPermissionProvider )
assertEquals ( ConfigurationParameters . EMPTY , new CugConfiguration ( ) . getParameters ( ) )
assertTrue ( acMgr instanceof CugAccessControlManager )
assertArrayEquals ( AbstractCugTest . SUPPORTED_PATHS , configuration . getParameters ( ) . getConfigValue ( CugConstants . PARAM_CUG_SUPPORTED_PATHS , new String [ 0 ] ) )
assertFalse ( testRoot . getTree ( "/content/rep:policy" ) . exists ( ) )
assertFalse ( getTargetNode ( ) . hasNode ( REP_CUG_POLICY ) )
assertFalse ( importer . init ( s , root , getNamePathMapper ( ) , false , ImportUUIDBehavior . IMPORT_UUID_COLLISION_REMOVE_EXISTING , new ReferenceChangeTracker ( ) , getSecurityProvider ( ) ) )
assertTrue ( cugPermProvider . getPrivileges ( root . getTree ( p ) ) . isEmpty ( ) )
assertTrue ( createCugPolicy ( principals ) instanceof PrincipalSetPolicy )
assertEquals ( path , empty . getPath ( ) )
assertEquals ( "/quercus:testPath" , empty . getPath ( ) )
assertEquals ( expected , CugUtil . getSupportedPaths ( CUG_CONFIG , Mounts . defaultMountInfoProvider ( ) ) )
assertEquals ( Permissions . NO_PERMISSION , pp . supportedPermissions ( TreeLocation . create ( hiddenTree ) , Permissions . READ ) )
assertTrue ( root . getTree ( "/" ) . hasChild ( REP_CUG_POLICY ) )
assertEquals ( p , Permissions . NO_PERMISSION , cugPermProvider . supportedPermissions ( TreeLocation . create ( root . getTree ( p ) ) , Permissions . READ ) )
assertFalse ( immutableRoot . getTree ( PathUtils . ROOT_PATH ) . hasProperty ( HIDDEN_NESTED_CUGS ) )
assertFalse ( tlp . contains ( p ) )
assertFalse ( testRoot . getTree ( VersionConstants . VERSION_STORE_PATH ) . exists ( ) )
assertTrue ( t . getPath ( ) , tp instanceof EmptyCugTreePermission )
assertTrue ( tp instanceof EmptyCugTreePermission )
assertEquals ( tree , atp . getTree ( ) )
assertTrue ( aggregationFilter . stop ( createPermissionProvider ( root , systemUserPrincipals . toArray ( new Principal [ 0 ] ) ) , systemUserPrincipals ) )
assertFalse ( aggregationFilter . stop ( createAccessControlManager ( root ) , ImmutableSet . of ( new PrincipalImpl ( "invalid" ) ) ) )
assertTrue ( CTX . definesContextRoot ( mockTree ( REP_PRINCIPAL_POLICY , NT_REP_PRINCIPAL_POLICY , true ) ) )
assertFalse ( filter . canHandle ( singleton ( getUserManager ( root ) . createGroup ( "group" ) . getPrincipal ( ) ) ) )
assertFalse ( filter . canHandle ( ImmutableSet . of ( getTestSystemUser ( ) . getPrincipal ( ) , getTestUser ( ) . getPrincipal ( ) ) ) )
assertEquals ( PATH , provider . getFilterRoot ( ) )
assertNotNull ( filter )
assertEquals ( getTestSystemUser ( ) . getPrincipal ( ) , immutable . getPrincipal ( ) )
assertNotSame ( pm , mgrProvider . getPrincipalManager ( ) )
assertNotSame ( pm , mgrProvider . getPrivilegeManager ( ) )
assertNotSame ( pbp , mgrProvider . getPrivilegeBitsProvider ( ) )
assertTrue ( permissionProvider . getPrivileges ( mockReadOnlyTree ( TreeType . HIDDEN ) ) . isEmpty ( ) )
assertTrue ( permissionProvider . getPrivileges ( mockReadOnlyTree ( TreeType . INTERNAL ) ) . isEmpty ( ) )
assertFalse ( Iterables . contains ( rootState . getNames ( JcrConstants . JCR_MIXINTYPES ) , MIX_REP_PRINCIPAL_BASED_MIXIN ) )
assertEquals ( 0 , mgr . getApplicablePolicies ( validPrincipal ) . length )
assertEquals ( 0 , effective . length )
assertEquals ( 0 , emptyPolicy . size ( ) )
assertEquals ( policy . getEntries ( ) . isEmpty ( ) , policy . isEmpty ( ) )
assertTrue ( init ( true , ImportUUIDBehavior . IMPORT_UUID_COLLISION_THROW ) )
assertFalse ( importer . handlePropInfo ( tree , mockPropInfo ( "wrongName" ) , mock ( PropertyDefinition . class ) ) )
assertFalse ( importer . handlePropInfo ( tree , mockPropInfo ( new PrincipalImpl ( "notFound" ) ) , mockPropertyDefinition ( getJcrName ( NT_REP_PRINCIPAL_POLICY ) ) ) )
assertTrue ( importer . handlePropInfo ( createPolicyTree ( user ) , mockPropInfo ( user . getPrincipal ( ) ) , mockPropertyDefinition ( getJcrName ( NT_REP_PRINCIPAL_POLICY ) ) ) )
assertTrue ( root . getTree ( oakPath ) . hasProperty ( REP_PRINCIPAL_NAME ) )
assertFalse ( importer . start ( mock ( Tree . class ) ) )
assertTrue ( importer . start ( policyTree ) )
assertFalse ( permissionProvider . getRepositoryPermission ( ) . isGranted ( Permissions . READ ) )
assertEquals ( 0 , applicable . length )
assertEquals ( 1 , acl . size ( ) )
assertFalse ( Utils . isPrincipalPolicyTree ( mockTree ( false , NT_REP_PRINCIPAL_POLICY , REP_PRINCIPAL_POLICY ) ) )
assertFalse ( Utils . isPrincipalPolicyTree ( mockTree ( true , REP_RESTRICTIONS , NT_REP_PRINCIPAL_POLICY ) ) )
assertFalse ( Utils . isPrincipalPolicyTree ( mockTree ( true , REP_RESTRICTIONS , NT_REP_RESTRICTIONS ) ) )
assertNotEquals ( vhPath , tp . getTree ( ) . getPath ( ) )
assertNotEquals ( versionPath , tp . getTree ( ) . getPath ( ) )
assertTrue ( versionTp instanceof AbstractTreePermission )
assertTrue ( labelsTp instanceof AbstractTreePermission )
assertTrue ( v1Tree . exists ( ) )
assertTrue ( identifiers . contains ( identifier ) )
assertEquals ( "identifier" , e . getMessage ( ) )
assertTrue ( "file" . equals ( e . getMessage ( ) ) )
assertTrue ( "identifier" . equals ( e . getMessage ( ) ) )
assertTrue ( "prefix" . equals ( e . getMessage ( ) ) )
assertNotNull ( context . getService ( AbstractSharedCachingDataStore . class ) )
assertEquals ( data . length , rec . getLength ( ) )
assertTrue ( Sets . symmetricDifference ( cluster . blobStoreState . blobsPresent , existingAfterGC ) . isEmpty ( ) )
assertTrue ( Sets . symmetricDifference ( cluster . blobStoreState . blobsPresent , existingAfterGC ) . isEmpty ( ) )
assertFalse ( dataStore . exists ( new DataIdentifier ( ID_PREFIX + 0 ) ) )
assertFalse ( pendingUploads . exists ( ) )
assertFalse ( pendingUploads . exists ( ) )
assertEquals ( 15 , cache . getStats ( ) . getElementCount ( ) , cache . getStats ( ) . getElementCount ( ) )
assertEquals ( added , retrieved )
assertTrue ( Files . equal ( temp , uploader . read ( ID_PREFIX + 0 ) ) )
assertThat ( lc . getLogs ( ) . toString ( ) , containsString ( "Error in reading pending uploads map" ) )
assertEquals ( "Incorrect elements after add snapshot" , initAdd , retrieved )
assertEquals ( "Incorrect elements after add snapshot" , initAdd , retrieved )
assertEquals ( "Incorrect elements after add snapshot reading file" , initAdd , retrieved )
assertEquals ( "Incorrect elements with snapshot after add" , initAdd , retrieved )
assertEquals ( "Incorrect elements after remove" , initAdd , retrieved )
assertEquals ( "path not equal" , nasPath , props . getProperty ( FSBackend . FS_BACKEND_PATH ) )
assertEquals ( 1000 , dbs . getDataStore ( ) . getMinRecordLength ( ) )
assertTrue ( noop . isEmpty ( ) )
assertNotNull ( uri )
assertNotNull ( ds . getDownloadURI ( id , DataRecordDownloadOptions . DEFAULT ) )
assertNull ( ds . getDownloadURI ( id , DataRecordDownloadOptions . DEFAULT ) )
assertNull ( dataStore . getDownloadURI ( new DataIdentifier ( "testIdentifier" ) , DataRecordDownloadOptions . DEFAULT ) )
assertEquals ( "foo" , b . getContentIdentity ( ) )
assertTrue ( closed . get ( ) )
assertTrue ( ret . toString ( ) , ret . isEmpty ( ) )
assertEquals ( 1 , collector . uploadCount )
assertEquals ( "i" , iCharacter )
assertArrayEquals ( Arrays . toString ( list . toArray ( ) ) , list . toArray ( ) , retrieved . toArray ( ) )
assertArrayEquals ( Arrays . toString ( list . toArray ( ) ) , list . toArray ( ) , retrieved . toArray ( ) )
assertEquals ( e . getValue ( ) . intValue ( ) , StringUtils . estimateMemoryUsage ( e . getKey ( ) ) )
assertEquals ( "Callback should still be invoked if already done" , 1 , runnable . count )
assertEquals ( "" + i , a . getProperties ( ) . get ( "x" + i ) )
assertTrue ( logs . isEmpty ( ) )
assertEquals ( NAME , cacheStats . getName ( ) )
assertEquals ( ( KEYS - ( double ) misses - fails ) / KEYS , cacheStats . getHitRate ( ) , Double . MIN_VALUE )
assertEquals ( misses + fails , cacheStats . getMissCount ( ) )
assertEquals ( ( ( double ) misses + fails ) / KEYS , cacheStats . getMissRate ( ) , Double . MIN_VALUE )
assertEquals ( misses + fails , cacheStats . getLoadCount ( ) )
assertEquals ( 10 , test . getUnchecked ( 1 ) . intValue ( ) )
assertNull ( lookup ( context , "name" ) )
assertNull ( lookup ( context , "name" ) )
assertEquals ( "42" , lookup ( context , "name" ) )
assertEquals ( "value" , lookup ( context , "name" ) )
assertNull ( lookup ( context , "name" ) )
assertNull ( lookup ( context , "name" ) )
assertNull ( lookup ( context , "name" ) )
assertEquals ( "value" , lookup ( context , "name" ) )
assertEquals ( cs1 , cs2 )
assertEquals ( of ( "s1" ) , track ( Service1 . class ) )
assertFalse ( getRegisteredTimeSeries ( statsProvider ) . contains ( "test" ) )
assertEquals ( "test" , cs . getWorkspaceName ( ) )
assertNull ( root . getBlob ( "reference" ) )
assertNotNull ( pp )
assertTrue ( child instanceof SecureNodeBuilder )
assertTrue ( secureNodeBuilder . exists ( ) )
assertTrue ( secureNodeBuilder . getChildNode ( NAME_ACCESSIBLE ) . exists ( ) )
assertTrue ( ns instanceof SecureNodeState )
assertTrue ( ns instanceof SecureNodeState )
assertTrue ( ns instanceof SecureNodeState )
assertEquals ( 2 , Iterables . size ( secureNodeBuilder . getProperties ( ) ) )
assertEquals ( 0 , Iterables . size ( secureNodeBuilder . getProperties ( ) ) )
assertNull ( secureNodeBuilder . getName ( "names" ) )
assertEquals ( "value" , secureNodeBuilder . getName ( "name" ) )
assertTrue ( secureNodeBuilder . hasProperty ( NAME_NON_ACCESSIBLE ) )
assertFalse ( secureNodeBuilder . hasProperty ( "prop" ) )
assertNull ( npMapper . getOakPath ( jcrPath ) )
assertNull ( npMapper . getOakPath ( path ) )
assertNull ( "the oak:increment should never be set" , builder . getProperty ( PROP_INCREMENT ) )
assertNull ( p )
assertNull ( p )
assertFalse ( ourRoot . getTree ( "/x" ) . exists ( ) )
assertNull ( p )
assertFalse ( cleaned . get ( ) )
assertTrue ( ( ( ContextAwareCallback ) provider . callback ) . getIndexingContext ( ) . isAsync ( ) )
assertFalse ( provider . getContext ( indexPath ) . isReindexing ( ) )
assertTrue ( actual . isEmpty ( ) )
assertNotNull ( lockToken )
assertTrue ( idxBuilder . hasProperty ( "barIndexProp" ) )
assertEquals ( info . checkpoint , info2 . checkpoint )
assertTrue ( updater . getIndexPaths ( ) . contains ( "/a" ) )
assertThat ( custom . getLogs ( ) , is ( expectedLogs ) )
assertEquals ( 1L , cd . get ( "valueCount" ) )
assertTrue ( callbackInvoked . get ( ) )
assertTrue ( disabledIndexes . isEmpty ( ) )
assertTrue ( disabledIndexes . isEmpty ( ) )
assertTrue ( disabledIndexes . isEmpty ( ) )
assertEquals ( 5 , statsProvider . getRepoStats ( ) . getCounter ( Type . SESSION_COUNT ) . get ( ) )
assertNotEquals ( statsProvider . getMeter ( Type . OBSERVATION_EVENT_COUNTER . name ( ) , StatsOptions . TIME_SERIES_ONLY ) , NoopStats . INSTANCE )
assertNull ( context . getService ( StatisticsProvider . class ) )
assertNotSame ( "content should not be identical to decorated" , content , decorated )
assertNotNull ( frozenNode . getProperty ( JcrConstants . JCR_UUID ) )
assertThat ( reporter , hasReportedProperty ( 10 , any ( String . class ) ) )
assertTrue ( Clock . ACCURATE . getTime ( ) - t0 >= 1000 )
assertEquals ( ConstantFilter . EXCLUDE_ALL , condition . createFilter ( EMPTY_NODE , EMPTY_NODE ) )
assertEquals ( ConstantFilter . INCLUDE_ALL , condition . createFilter ( EMPTY_NODE , EMPTY_NODE ) )
assertEquals ( ConstantFilter . EXCLUDE_ALL , condition . createFilter ( EMPTY_NODE , EMPTY_NODE ) )
assertTrue ( filter . includeAdd ( "q" , tree . getNodeState ( ) ) )
assertTrue ( filter . includeAdd ( "q" , tree . getNodeState ( ) ) )
assertTrue ( p . test ( createWithProperty ( name , value ) ) )
assertFalse ( p . test ( createWithProperty ( name , value ) ) )
assertEquals ( nodeC , selector . select ( filter , null , null ) )
assertTrue ( immutable . isRoot ( ) )
assertEquals ( "nonExisting" , immutable . getChild ( "nonExisting" ) . getName ( ) )
assertTrue ( getHiddenTree ( immutable ) . exists ( ) )
assertNotNull ( orderable . getProperty ( TreeConstants . OAK_CHILD_ORDER ) )
assertEquals ( "[is null]" , f . getPropertyRestrictions ( "c" ) . toString ( ) )
assertEquals ( buff2 . toString ( ) , sql2 )
assertEquals ( 10 , count )
assertTrue ( q . contains ( token ) )
assertEquals ( "bar" , plan . getAttribute ( "foo" ) )
assertNull ( securityProvider . getConfiguration ( UserConfiguration . class ) )
assertTrue ( Maps . difference ( expected , authenticationConfiguration . getParameters ( ) ) . areEqual ( ) )
assertEquals ( AuthenticationConfiguration . NAME , authConfiguration . getName ( ) )
assertTrue ( lcp instanceof LoginContextProviderImpl )
assertArrayEquals ( simpleCreds . getPassword ( ) , cb . getPassword ( ) )
assertEquals ( "id" , cb . getName ( ) )
assertNull ( cb . getName ( ) )
assertEquals ( anonymousID , authInfo . getUserID ( ) )
assertEquals ( anonymousID , authInfo . getUserID ( ) )
assertEquals ( "userid must be correct" , "admin" , cs . getAuthInfo ( ) . getUserID ( ) )
assertFalse ( authentication . authenticate ( creds ) )
assertNotNull ( info )
assertTrue ( auth . authenticate ( tc ) )
assertTrue ( auth . authenticate ( tc ) )
assertEquals ( TokenConfiguration . NAME , tc . getName ( ) )
assertTrue ( tp instanceof TokenProviderImpl )
assertTrue ( ctx instanceof TokenContext )
assertTrue ( info . remove ( ) )
assertFalse ( root . getTree ( tokenNodePath ) . exists ( ) )
assertEquals ( sc . getUserID ( ) , cs . getAuthInfo ( ) . getUserID ( ) )
assertNull ( tp . getTokenInfo ( valid . getToken ( ) ) )
assertNull ( readOnlyTp . createToken ( getTestUser ( ) . getID ( ) , ImmutableMap . of ( ) ) )
assertNotNull ( readOnlyInfo )
assertNull ( info )
assertNull ( tokenProvider . getTokenInfo ( token ) )
assertTrue ( getTokenTree ( info ) . exists ( ) )
assertEquals ( 60 , e . getCode ( ) )
assertEquals ( 63 , e . getCode ( ) )
assertEquals ( 66 , e . getCode ( ) )
assertEquals ( 63 , e . getCode ( ) )
assertEquals ( 68 , e . getCode ( ) )
assertEquals ( 68 , e . getCode ( ) )
assertEquals ( 69 , e . getCode ( ) )
assertEquals ( anonymousID , authInfo . getUserID ( ) )
assertEquals ( user . getID ( ) , authInfo . getUserID ( ) )
assertEquals ( AuthorizationConfiguration . NAME , authorizationConfiguration . getName ( ) )
assertTrue ( pp instanceof PermissionProviderImpl )
assertNull ( f . get ( authorizationConfiguration ) )
assertFalse ( AuthorizationContext . getInstance ( ) . definesContextRoot ( tree ) )
assertEquals ( PropertyType . UNDEFINED , acl . getRestrictionType ( "unknownRestrictionName" ) )
assertFalse ( acl . addEntry ( testPrincipal , testPrivileges , true , Collections . emptyMap ( ) ) )
assertFalse ( importer . init ( s , root , getNamePathMapper ( ) , false , ImportUUIDBehavior . IMPORT_UUID_COLLISION_THROW , new ReferenceChangeTracker ( ) , getSecurityProvider ( ) ) )
assertTrue ( importer . init ( mockJackrabbitSession ( ) , root , getNamePathMapper ( ) , isWorkspaceImport ( ) , ImportUUIDBehavior . IMPORT_UUID_COLLISION_THROW , new ReferenceChangeTracker ( ) , getSecurityProvider ( ) ) )
assertEquals ( isWorkspaceImport ( ) , importer . init ( s , root , getNamePathMapper ( ) , isWorkspaceImport ( ) , ImportUUIDBehavior . IMPORT_UUID_COLLISION_REPLACE_EXISTING , new ReferenceChangeTracker ( ) , getSecurityProvider ( ) ) )
assertFalse ( importer . start ( aclTree ) )
assertFalse ( importer . start ( repoPolicy ) )
assertEquals ( unknownPrincipalInfo . getValue ( PropertyType . STRING ) . getString ( ) , TreeUtil . getString ( aceTree , REP_PRINCIPAL_NAME ) )
assertEquals ( privilege , p )
assertTrue ( policy instanceof ImmutableACL )
assertTrue ( acMgr . getApplicablePolicies ( testPath ) . hasNext ( ) )
assertTrue ( acMgr . getApplicablePolicies ( ( String ) null ) . hasNext ( ) )
assertTrue ( applicable [ 0 ] instanceof ACL )
assertTrue ( acl . addAccessControlEntry ( EveryonePrincipal . getInstance ( ) , privilegesFromNames ( PrivilegeConstants . REP_READ_PROPERTIES ) ) )
assertTrue ( applicable [ 0 ] instanceof ACL )
assertEquals ( 0 , effective . length )
assertEquals ( getBitsProvider ( ) . getBits ( JCR_READ ) , ace . getPrivilegeBits ( ) )
assertEquals ( nameValue , val )
assertTrue ( ace . getRestrictions ( ) . isEmpty ( ) )
assertNotEquals ( nodeAcl , acl )
assertNotEquals ( nodeAcl , acl )
assertEquals ( 0 , comparator . compare ( policy , policy ) )
assertEquals ( - 1 , comparator . compare ( policy1 , policy2 ) )
assertEquals ( 1 , comparator . compare ( policy1 , policy2 ) )
assertEquals ( expected , comparator . compare ( policy1 , policy2 ) )
assertEquals ( expected , comparator . compare ( policy1 , policy2 ) )
assertNotEquals ( principalAcl , getPrincipalAcl ( getAccessControlManager ( root ) , EveryonePrincipal . getInstance ( ) ) )
assertTrue ( found )
assertFalse ( Util . isACE ( t , ReadOnlyNodeTypeManager . getInstance ( root , getNamePathMapper ( ) ) ) )
assertFalse ( Util . isACE ( root . getTree ( PathUtils . ROOT_PATH ) , ReadOnlyNodeTypeManager . getInstance ( root , getNamePathMapper ( ) ) ) )
assertEquals ( 2 , cnt )
assertEquals ( 0 , applicable . length )
assertArrayEquals ( new JackrabbitAccessControlPolicy [ ] { policy } , composite . getPolicies ( EveryonePrincipal . getInstance ( ) ) )
assertFalse ( accessControlManager instanceof CompositeAccessControlManager )
assertFalse ( rp instanceof CompositeRestrictionProvider )
assertTrue ( accessControlManager instanceof CompositeAccessControlManager )
assertTrue ( pp instanceof CompositePermissionProvider )
assertTrue ( rp instanceof CompositeRestrictionProvider )
assertFalse ( rp instanceof CompositeRestrictionProvider )
assertTrue ( tp instanceof LimitedTreePermission )
assertTrue ( tp instanceof LimitedTreePermission )
assertTrue ( tp instanceof LimitedTreePermission )
assertEquals ( expected , cppAdminUser . getPrivileges ( tree ) )
assertEquals ( expected , cppTestUser . getPrivileges ( null ) )
assertEquals ( 2 , ( ( TreePermission [ ] ) tpField . get ( tp ) ) . length )
assertEquals ( expected , cppTestUser . getPrivileges ( null ) )
assertFalse ( a . hasProperty ( TreeConstants . OAK_CHILD_ORDER ) )
assertEquals ( 2 , a . getPropertyCount ( ) )
assertNull ( a . getPropertyStatus ( TreeConstants . OAK_CHILD_ORDER ) )
assertFalse ( a . hasProperty ( propName ) )
assertNull ( a . getPropertyStatus ( propName ) )
assertEquals ( 0 , parent . getChildrenCount ( 1 ) )
assertEquals ( expected , ImmutableSet . copyOf ( testAcMgr . getPrivileges ( null ) ) )
assertFalse ( a . hasProperty ( "aProp" ) )
assertFalse ( vs . exists ( ) )
assertTrue ( r . getTree ( "/" ) . exists ( ) )
assertTrue ( tree . exists ( ) )
assertTrue ( empty . getEntries ( "/path" ) . isEmpty ( ) )
assertEquals ( 2 , permissionStore . getNumEntries ( EveryonePrincipal . NAME , 10 ) . size )
assertTrue ( validator instanceof VisibleValidator )
assertTrue ( tree . exists ( ) )
assertFalse ( permissionCacheBuilder . init ( ImmutableSet . of ( "a" , "b" , "c" ) , createStrategy ( Long . MAX_VALUE , maxPaths , false ) ) )
assertFalse ( permissionCacheBuilder . init ( ImmutableSet . of ( "a" , "b" , "c" ) , createStrategy ( Long . MAX_VALUE , maxPaths , false ) ) )
assertFalse ( permissionCacheBuilder . init ( ImmutableSet . of ( "a" , "b" , "c" ) , createStrategy ( Long . MAX_VALUE , 25 , false ) ) )
assertTrue ( cache . getEntries ( t ) . isEmpty ( ) )
assertNull ( entries )
assertTrue ( result . isEmpty ( ) )
assertEquals ( h1 . toString ( ) , h2 . toString ( ) )
assertNull ( permissionStore . load ( testPrincipal . getName ( ) , testPath ) )
assertEquals ( NumEntries . valueOf ( 0 , true ) , permissionStore . getNumEntries ( testPrincipal . getName ( ) , Long . MAX_VALUE ) )
assertEquals ( NumEntries . valueOf ( 2 , false ) , permissionStore . getNumEntries ( EveryonePrincipal . NAME , Long . MAX_VALUE ) )
assertFalse ( ps . exists ( ) )
assertTrue ( privilegeNames . isEmpty ( ) )
assertNull ( PermissionUtil . getReadOnlyTreeOrNull ( null , r ) )
assertTrue ( tp instanceof RepoPolicyTreePermission )
assertFalse ( GlobPattern . create ( "/a/b/c/d" , "/*" ) . matches ( ) )
MATCH . values ( ) . forEach ( testPaths -> testPaths . forEach ( testPath -> assertTrue ( gp . matches ( testPath ) ) ) )
assertFalse ( sc . getParameters ( ) . containsKey ( "key" ) )
assertFalse ( sc . getParameters ( ) . containsKey ( "key" ) )
assertNull ( securityProvider . getWhiteboard ( ) )
assertEquals ( PARAMS , securityProvider . getParameters ( UserConfiguration . NAME ) )
assertNull ( securityProvider . getConfiguration ( AuthenticationConfiguration . class ) )
assertEquals ( PARAMS , securityProvider . getParameters ( AuthorizationConfiguration . NAME ) )
assertEquals ( PARAMS , securityProvider . getParameters ( PrivilegeConfiguration . NAME ) )
assertNull ( securityProvider . getConfiguration ( TokenConfiguration . class ) )
assertNull ( context . getService ( SecurityProvider . class ) )
assertNull ( context . getService ( SecurityProvider . class ) )
assertTrue ( principalProvider . getPrincipals ( testGroup . getID ( ) ) . isEmpty ( ) )
assertEquals ( 0 , Iterators . size ( result ) )
assertNull ( principalProvider . getPrincipal ( getTestUser ( ) . getPrincipal ( ) . getName ( ) ) )
assertNull ( createPrincipalProvider ( um ) . getPrincipal ( getTestUser ( ) . getPrincipal ( ) . getName ( ) ) )
assertTrue ( principalProvider . getMembershipPrincipals ( testUser . getPrincipal ( ) ) . isEmpty ( ) )
assertEquals ( Sets . newHashSet ( EveryonePrincipal . getInstance ( ) ) , createPrincipalProvider ( um ) . getMembershipPrincipals ( p ) )
assertFalse ( principalProvider . findPrincipals ( PrincipalManager . SEARCH_TYPE_NOT_GROUP ) . hasNext ( ) )
assertFalse ( principalProvider . findPrincipals ( testUser . getPrincipal ( ) . getName ( ) , false , PrincipalManager . SEARCH_TYPE_NOT_GROUP , 0 , Long . MAX_VALUE ) . hasNext ( ) )
assertEquals ( ImmutableSet . of ( EveryonePrincipal . getInstance ( ) ) , membership )
assertTrue ( aggregates . contains ( newPrivilege ) )
assertEquals ( PRIVILEGES_PATH , bitsProvider . getPrivilegesTree ( ) . getPath ( ) )
assertEquals ( 2 , names . size ( ) )
assertEquals ( NON_AGGREGATE_PRIVILEGES , ImmutableSet . copyOf ( bitsProvider . getAggregatedPrivilegeNames ( JCR_ALL ) ) )
assertEquals ( PrivilegeConfiguration . NAME , configuration . getName ( ) )
assertTrue ( configuration . getRepositoryInitializer ( ) instanceof PrivilegeInitializer )
assertTrue ( ctx . definesProperty ( mockTree ( "anyName" , ntName ) , property ) )
assertFalse ( ctx . definesTree ( treeProvider . createReadOnlyTree ( EmptyNodeState . EMPTY_NODE ) ) )
assertFalse ( ctx . definesTree ( mockTree ( PrivilegeConstants . REP_PRIVILEGES , ntName ) ) )
assertNull ( reader . readDefinition ( "invalid" ) )
assertEquals ( JCR_READ_ACCESS_CONTROL , privilege . getName ( ) )
assertTrue ( failed . isEmpty ( ) )
assertTrue ( failed . isEmpty ( ) )
assertFalse ( failed . isEmpty ( ) )
assertEquals ( ImmutableSet . copyOf ( NON_EXISTING_IDS ) , failed )
assertEquals ( t . getPath ( ) , authorizable . getTree ( ) . getPath ( ) )
assertEquals ( - 1 , it . getSize ( ) )
assertEquals ( expected , ImmutableSet . copyOf ( names ) )
assertNull ( properties . getProperty ( UserConstants . REP_AUTHORIZABLE_ID ) )
assertArrayEquals ( new Value [ ] { v } , properties . getProperty ( "mvProp" ) )
assertFalse ( getAuthorizableTree ( getTestUser ( ) ) . hasChild ( CacheConstants . REP_CACHE ) )
assertEquals ( 1 , Iterators . size ( group . getMembers ( ) ) )
assertEquals ( 1 , Iterators . size ( group . getMembers ( ) ) )
assertEquals ( 1 , Iterators . size ( member . memberOf ( ) ) )
assertEquals ( 1 , Iterators . size ( member . memberOf ( ) ) )
assertTrue ( dmp instanceof EveryoneMembershipProvider )
assertFalse ( everyoneGroup . addMember ( everyoneGroup ) )
assertNull ( uMgr . getAuthorizable ( groupId , Group . class ) )
assertFalse ( group . addMember ( everyoneGroup ) )
assertFalse ( group . removeMember ( getTestUser ( ) ) )
assertTrue ( groupPrincipal . isMember ( getTestUser ( ) ) )
assertFalse ( impersonation . getImpersonators ( ) . hasNext ( ) )
assertTrue ( impersonation . allows ( createSubject ( getAdminPrincipal ( ) ) ) )
assertTrue ( impersonation . allows ( createSubject ( ( AdminPrincipal ) ( ) -> "principalName" ) ) )
assertTrue ( impersonation . allows ( createSubject ( new PrincipalImpl ( getAdminPrincipal ( ) . getName ( ) ) ) ) )
assertTrue ( impersonation . allows ( createSubject ( impersonator . getPrincipal ( ) ) ) )
assertTrue ( impersonation . allows ( createSubject ( impersonator . getPrincipal ( ) , groupPrincipal ) ) )
assertFalse ( imp . allows ( createSubject ( nonExisting ) ) )
assertNotNull ( createAuthorizable ( false , null ) )
assertTrue ( authorizable . getPath ( ) . startsWith ( UserConstants . DEFAULT_USER_PATH + "/a/b/c" ) )
assertTrue ( authorizable . getPath ( ) . startsWith ( UserConstants . DEFAULT_GROUP_PATH + "/a/b/c" ) )
assertEquals ( UserConstants . DEFAULT_USER_PATH , PathUtils . getAncestorPath ( authorizable . getPath ( ) , 1 ) )
assertTrue ( mp . removeMember ( getTree ( gr ) , getTree ( member ) ) )
assertTrue ( failed . isEmpty ( ) )
assertTrue ( mp . isDeclaredMember ( getTree ( g ) , getTree ( path ) ) )
assertTrue ( mp . isDeclaredMember ( getTree ( g ) , getTree ( path ) ) )
assertFalse ( grp . addMember ( userMgr . getAuthorizable ( id ) ) )
assertFalse ( writer . addMember ( groupTree , contentId ) )
assertFalse ( getTree ( g ) . hasChild ( REP_MEMBERS_LIST ) )
assertTrue ( a . authenticate ( new SimpleCredentials ( userId , userId . toCharArray ( ) ) ) )
assertTrue ( a . authenticate ( new SimpleCredentials ( userId , userId . toCharArray ( ) ) ) )
assertTrue ( newModTime > 0 )
assertTrue ( a . authenticate ( new SimpleCredentials ( userId , userId . toCharArray ( ) ) ) )
assertFalse ( root . getTree ( adminUser . getPath ( ) ) . getChild ( UserConstants . REP_PWD ) . exists ( ) )
assertFalse ( root . getTree ( user . getPath ( ) ) . hasChild ( REP_PWD ) )
assertEquals ( 10 , getHistory ( user ) . size ( ) )
assertFalse ( ph . updatePasswordHistory ( root . getTree ( u . getPath ( ) ) , "pw" ) )
assertEquals ( ImmutableSet . copyOf ( NON_EXISTING_IDS ) , failed )
assertTrue ( failed . isEmpty ( ) )
assertTrue ( PasswordUtil . isSame ( userTree . getProperty ( UserConstants . REP_PASSWORD ) . getValue ( Type . STRING ) , "newPw" ) )
assertTrue ( u . getPath ( ) . contains ( "/" + REL_PATH + "/" ) )
assertTrue ( createUser ( null ) instanceof SystemUserImpl )
assertFalse ( createUser ( null ) . isGroup ( ) )
assertFalse ( authentication . authenticate ( new SimpleCredentials ( userId , userId . toCharArray ( ) ) ) )
assertFalse ( authentication . authenticate ( creds ) )
assertFalse ( a . authenticate ( sc ) )
assertTrue ( authentication . authenticate ( new SimpleCredentials ( userId , userId . toCharArray ( ) ) ) )
assertTrue ( authentication . authenticate ( new ImpersonationCredentials ( sc , adminSession . getAuthInfo ( ) ) ) )
assertTrue ( authentication . authenticate ( new ImpersonationCredentials ( sc , mockAuthInfo ( userId ) ) ) )
assertTrue ( ua . authenticate ( new GuestCredentials ( ) ) )
assertTrue ( authentication . authenticate ( PreAuthenticatedLogin . PRE_AUTHENTICATED ) )
assertEquals ( getTestUser ( ) . getPrincipal ( ) , authentication . getUserPrincipal ( ) )
assertEquals ( 8 , params . getConfigValue ( PARAM_DEFAULT_DEPTH , UserConstants . DEFAULT_DEPTH ) . intValue ( ) )
assertEquals ( defines , ctx . definesProperty ( mockTree ( "anyName" , ntName ) , property ) )
assertFalse ( ctx . definesTree ( mockTree ( "anyName" , ntName ) ) )
assertFalse ( ctx . definesInternal ( mockTree ( "anyName" , ntName ) ) )
assertTrue ( getAdminUser ( ) . isAdmin ( ) )
assertTrue ( groupTree . hasProperty ( REP_MEMBERS ) )
assertTrue ( groupTree . hasProperty ( REP_MEMBERS ) )
assertFalse ( importer . init ( s , root , getNamePathMapper ( ) , false , ImportUUIDBehavior . IMPORT_UUID_COLLISION_THROW , new ReferenceChangeTracker ( ) , getSecurityProvider ( ) ) )
assertFalse ( importer . init ( mockJackrabbitSession ( ) , root , getNamePathMapper ( ) , false , ImportUUIDBehavior . IMPORT_UUID_COLLISION_REMOVE_EXISTING , new ReferenceChangeTracker ( ) , sp ) )
assertEquals ( ! isAutosave ( ) , importer . init ( mockJackrabbitSession ( ) , root , getNamePathMapper ( ) , isWorkspaceImport ( ) , ImportUUIDBehavior . IMPORT_UUID_COLLISION_REMOVE_EXISTING , new ReferenceChangeTracker ( ) , getSecurityProvider ( ) ) )
assertFalse ( importer . init ( mockJackrabbitSession ( ) , root , getNamePathMapper ( ) , isWorkspaceImport ( ) , ImportUUIDBehavior . IMPORT_UUID_CREATE_NEW , new ReferenceChangeTracker ( ) , getSecurityProvider ( ) ) )
assertTrue ( importer . handlePropInfo ( userTree , createPropInfo ( REP_AUTHORIZABLE_ID , TEST_USER_ID ) , mockPropertyDefinition ( NT_REP_USER , false ) ) )
assertFalse ( importer . handlePropInfo ( groupTree , createPropInfo ( REP_PASSWORD , PasswordUtil . buildPasswordHash ( "pw" ) ) , mockPropertyDefinition ( NT_REP_USER , false ) ) )
assertTrue ( importer . handlePropInfo ( pwHistory , createPropInfo ( null , PasswordUtil . buildPasswordHash ( "pw" ) ) , pd ) )
assertFalse ( importer . handlePropInfo ( groupTree , createPropInfo ( REP_IMPERSONATORS , "impersonator1" ) , mockPropertyDefinition ( NT_REP_USER , true ) ) )
assertFalse ( importer . start ( createGroupTree ( ) ) )
assertTrue ( importer . start ( memberRefList ) )
assertFalse ( importer . start ( memberRefList ) )
assertFalse ( importer . start ( repMembers ) )
assertFalse ( importer . start ( repMembers ) )
assertFalse ( importer . start ( tree ) )
assertTrue ( importer . start ( memberRefList ) )
assertTrue ( importer . start ( repMembers ) )
assertNotNull ( su )
assertNull ( userMgr . getAuthorizable ( "" ) )
assertNull ( userMgr . getAuthorizable ( "" , User . class ) )
assertNull ( userMgr . getAuthorizable ( null , User . class ) )
assertNull ( userMgr . getAuthorizable ( ( Principal ) null ) )
assertEquals ( authorizable . getPath ( ) , byPath . getPath ( ) )
assertNull ( userMgr . getAuthorizable ( ( Tree ) null ) )
assertNull ( userMgr . getAuthorizable ( root . getTree ( PathUtils . ROOT_PATH ) ) )
assertTrue ( principal instanceof TreeBasedPrincipal )
assertTrue ( principal instanceof SystemUserPrincipalImpl )
assertTrue ( principal instanceof AbstractGroupPrincipal )
assertTrue ( principalProvider . getPrincipals ( u . getID ( ) ) . isEmpty ( ) )
assertFalse ( principalProvider . getPrincipals ( getTestUser ( ) . getID ( ) ) . contains ( p ) )
assertEquals ( principals , principalsAgain )
assertNotNull ( getUserManager ( root ) . getAuthorizable ( "withoutId" ) )
assertEquals ( 0 , policies . length )
assertEquals ( dlg . getID ( ) , a . getID ( ) )
assertEquals ( dlg . getPrincipal ( ) , a . getPrincipal ( ) )
assertFalse ( a . removeProperty ( "propName" ) )
assertEquals ( dlg . getPath ( ) , a . getPath ( ) )
assertNull ( it . next ( ) )
assertEquals ( ImmutableSet . of ( "m1" , "m2" , "m3" ) , group . addMembers ( "m1" , "m2" , "m3" ) )
assertEquals ( ImmutableSet . of ( getTestUser ( ) . getID ( ) ) , group . removeMembers ( "u" , getTestUser ( ) . getID ( ) ) )
assertEquals ( QueryConstants . SEARCH_ROOT_PATH + path , QueryUtil . getSearchRoot ( type , ConfigurationParameters . of ( UserConstants . PARAM_USER_PATH , path , UserConstants . PARAM_GROUP_PATH , path ) ) )
ntNames . forEach ( ( key , value ) -> assertEquals ( value , QueryUtil . getNodeTypeName ( key ) ) )
assertEquals ( QueryUtils . escapeNodeName ( name ) , QueryUtil . escapeNodeName ( name ) )
assertEquals ( QueryUtils . escapeForQuery ( "myPrefix:" + value ) , QueryUtil . escapeForQuery ( "jcr:" + value , namePathMapper ) )
assertFalse ( ResultIterator . create ( ResultIterator . OFFSET_NONE , 0 , Iterators . singletonIterator ( "str" ) ) . hasNext ( ) )
assertEquals ( 1 , Iterators . size ( ResultIterator . create ( 1 , ResultIterator . MAX_ALL , ImmutableList . of ( "str" , "str" ) . iterator ( ) ) ) )
assertNull ( userRrta . apply ( row ) )
assertNull ( rrta . apply ( createResultRow ( r . getTree ( userPath ) ) ) )
assertEquals ( ImmutableList . of ( user , g2 , g ) , ImmutableList . copyOf ( result ) )
assertTrue ( statement . toString ( ) . contains ( " and " ) )
assertNull ( builder . getSortProperty ( ) )
assertTrue ( c instanceof Condition . And )
assertTrue ( c instanceof Condition . Or )
assertEquals ( AuthorizableNodeName . DEFAULT . generateNodeName ( TEST_ID ) , authorizableNodeName . generateNodeName ( TEST_ID ) )
assertNull ( factory . getAuthentication ( getUserConfiguration ( ) , root , "userId" ) )
assertTrue ( "testExcludedAllCommits" , fo . getBackgroundObserver ( ) . waitUntilStopped ( 5 , TimeUnit . SECONDS ) )
assertEquals ( "LEADER" , props . get ( ) . get ( "scheduler.runOn" ) )
assertEquals ( expectedPrincipals , authInfo . getPrincipals ( ) )
assertEquals ( expectedID , anonymousID )
assertEquals ( expectedId , testSession . getAuthInfo ( ) . getUserID ( ) )
assertTrue ( pp . isGranted ( "/test/a" , Permissions . getString ( ThreeRolesConstants . SUPPORTED_PERMISSIONS ) ) )
assertFalse ( permissionStoreTree . exists ( ) )
assertTrue ( testRoot . getTree ( testPath ) . exists ( ) )
assertTrue ( cs . getLatestRoot ( ) . getTree ( readablePath ) . exists ( ) )
assertEquals ( - 1 , effectivePolicies . length )
assertEquals ( expected , ImmutableSet . copyOf ( aggrPrivilege . getDeclaredAggregatePrivileges ( ) ) )
assertTrue ( hasPrivilege )
assertEquals ( expectedPw , TreeUtil . getString ( systemUserTree , UserConstants . REP_PASSWORD ) )
assertEquals ( expectedNodeName , nodeName )
assertFalse ( contentRepository . getDescriptors ( ) . getValue ( JackrabbitRepository . OPTION_USER_MANAGEMENT_SUPPORTED ) . getBoolean ( ) )
assertEquals ( expectedEquals , testUser . equals ( user2 ) )
assertFalse ( system . getChildNode ( DOCUMENT_NODE_STORE ) . exists ( ) )
assertFalse ( r2 . getTree ( "/" ) . hasChild ( "c" ) )
assertThat ( "root exists" , store . getRoot ( ) . exists ( ) , equalTo ( true ) )
assertThat ( "root(childCount)" , store . getRoot ( ) . getChildNodeCount ( 100 ) , equalTo ( 4l ) )
assertThat ( "root.tmp(childCount)" , store . getRoot ( ) . getChildNode ( "tmp" ) . getChildNodeCount ( 10 ) , equalTo ( 2l ) )
assertThat ( store . checkpointInfo ( checkpoint ) , equalTo ( info ) )
assertTrue ( store . release ( checkpoint ) )
assertThat ( retrievedBlob . getContentIdentity ( ) , equalTo ( createdBlob . getContentIdentity ( ) ) )
assertThat ( retrievedBlob . getContentIdentity ( ) , equalTo ( createdBlob . getContentIdentity ( ) ) )
assertNull ( "No PrivateStoreValidatorProvider should be registered for default mounts!" , validator )
assertEquals ( Status . NEW , c . getStatus ( ) )
assertEquals ( childNames [ index ++ ] , child . getName ( ) )
assertEquals ( "k=" + k , NEW , x . getChild ( "added" ) . getStatus ( ) )
assertNull ( retrievedId )
assertNull ( context . getService ( ConsolidatedDataStoreCacheStatsMBean . class ) )
assertNotNull ( "testUser must exist on 2nd cluster node" , userManager2 . getAuthorizable ( "testUser" ) )
assertEquals ( 1 , aces . length )
assertNull ( context . getService ( ConsolidatedDataStoreCacheStatsMBean . class ) )
assertEquals ( props , store . checkpointInfo ( cp ) )
assertTrue ( store . retrieve ( "r42-0-0" ) == null )
assertEquals ( N + 1 , state . getChildNodeCount ( N + 2 ) )
assertEquals ( base , root . getBaseState ( ) )
assertEquals ( 3 + initialCount , state . getPropertyCount ( ) )
assertNull ( n . getNodeOrNull ( "not/existing" ) )
assertNull ( n . getPropertyOrNull ( "not/existing" ) )
assertNotNull ( root . setProperty ( "test" , ( String ) null ) )
assertNotNull ( root . setProperty ( "test" , ( String [ ] ) null ) )
assertEquals ( "/jcr:primaryType" , property . getPath ( ) )
assertThat ( e . getMessage ( ) , containsString ( path ) )
assertEquals ( paths . get ( i ) , n2 . getPath ( ) )
assertEquals ( "/new" , n . getPath ( ) )
assertEquals ( "/parent/new" , n2 . getPath ( ) )
assertEquals ( "/moved" , n . getPath ( ) )
assertEquals ( "/moved" , n . getPath ( ) )
assertEquals ( "/new" , n2 . getPath ( ) )
assertEquals ( "/moved/new" , n . getPath ( ) )
assertEquals ( "/parent/new" , n2 . getPath ( ) )
assertEquals ( destPath , node1 . getPath ( ) )
assertEquals ( destPath , node1 . getPath ( ) )
assertEquals ( destPath , node1 . getPath ( ) )
assertEquals ( destPath , node1 . getPath ( ) )
assertEquals ( destPath , node1 . getPath ( ) )
assertNotNull ( repository )
assertEquals ( value , property . getDate ( ) . getTimeInMillis ( ) )
assertEquals ( childPath , child . getPath ( ) )
assertTrue ( superuser . nodeExists ( n . getPath ( ) ) )
assertTrue ( repository . getDescriptorValue ( Repository . OPTION_NODE_AND_PROPERTY_WITH_SAME_NAME_SUPPORTED ) . getBoolean ( ) )
assertEquals ( "foo" , n . getName ( ) )
assertEquals ( testPrefix + ":foo" , n . getName ( ) )
assertNull ( downloadURI )
assertNull ( upload )
assertNull ( downloadURI )
assertEquals ( "Same NoteType could be equal" , nt , testRootNode . getPrimaryNodeType ( ) )
assertEquals ( 90 , count )
assertEquals ( "/etc/p2/r" , n . getPath ( ) )
assertTrue ( testSession . itemExists ( acl . getPath ( ) + "/rep:policy" ) )
assertEquals ( "Node " + destParent . getPath ( ) + " is protected." , e . getMessage ( ) )
assertTrue ( type > PropertyType . UNDEFINED )
assertEquals ( pPath , p . getPath ( ) )
assertArrayEquals ( readPrivileges , testAcMgr . getPrivileges ( childPath ) )
assertFalse ( childNodeNames . contains ( "nodeToDeny" ) )
assertTrue ( n . hasProperty ( propertyName1 ) )
assertTrue ( n . hasProperty ( propertyName1 ) )
assertTrue ( n . hasProperty ( propertyName1 ) )
assertFalse ( testAcMgr . hasPrivileges ( n . getPath ( ) , versionPrivileges ) )
assertEquals ( n . getPath ( ) , versionablePath . getString ( ) )
assertEquals ( "PrincipalManager.getPrincipal returned Principal with different Name" , pcpl . getName ( ) , pp . getName ( ) )
assertTrue ( principalMgr . hasPrincipal ( memb . getName ( ) ) )
assertTrue ( principalMgr . hasPrincipal ( memb . getName ( ) ) )
assertNull ( user . getProperty ( path ) )
assertTrue ( gr . getPath ( ) . startsWith ( path ) )
assertTrue ( user . getPath ( ) . startsWith ( path ) )
assertEquals ( EveryonePrincipal . NAME , everyone . getPrincipal ( ) . getName ( ) )
assertTrue ( memberOfEveryone )
assertTrue ( "Searching for 'null' must find the created group." , found )
assertFalse ( it . next ( ) . isGroup ( ) )
assertTrueMemberOfContainsGroup ( auth . memberOf ( ) , group )
assertTrueMemberOfContainsGroup ( auth . declaredMemberOf ( ) , group )
assertFalse ( uid . equals ( a . getID ( ) ) )
assertFalse ( newGroup . addMember ( newGroup ) )
assertNotNull ( adminUserManager . getAuthorizable ( uid ) )
assertNotNull ( getUserManager ( session ) . getAuthorizableByPath ( authorizable . getPath ( ) ) )
assertEquals ( u . getID ( ) , uSession . getUserID ( ) )
assertEquals ( "Expect group with exact ID" , id , gr . getID ( ) )
assertNull ( userMgr . getAuthorizable ( uid ) )
assertTrue ( authorizable instanceof User )
assertFalse ( hash . equals ( getNode ( user , superuser ) . getProperty ( UserConstants . REP_PASSWORD ) . getString ( ) ) )
assertFalse ( hash . equals ( getNode ( user , superuser ) . getProperty ( UserConstants . REP_PASSWORD ) . getString ( ) ) )
assertFalse ( c . getProperty ( "reindex" ) . getBoolean ( ) )
assertEquals ( 1 , counterValue ( session , counter . getPath ( ) ) )
assertArrayEquals ( FileUtils . EMPTY_FILE_ARRAY , copier . getIndexWorkDir ( ) . listFiles ( ) )
assertThat ( fileNames , contains ( "t1" ) )
assertNull ( planner . getPlan ( ) )
assertNotNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNotNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNotNull ( planner . getPlan ( ) )
assertNotNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNotNull ( planner . getPlan ( ) )
assertNotNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNull ( "Index specifying a tag selection policy is not selected" , plan )
assertEquals ( 2 , stats . numDocs ( ) )
assertEquals ( 1 , stats . numDocs ( ) )
assertTrue ( assertionLogPresent ( logs , invalidJcrPrimaryTypeLog ( ) ) )
assertFalse ( assertionLogPresent ( logs , invalidJcrPrimaryTypeLog ( ) ) )
assertEquals ( IndexFormatVersion . V1 , defn . getVersion ( ) )
assertEquals ( IndexFormatVersion . V2 , defn . getVersion ( ) )
assertEquals ( IndexFormatVersion . V1 , defn . getVersion ( ) )
assertTrue ( ! idxDefn . getApplicableIndexingRule ( TestUtil . NT_TEST ) . getNotNullCheckEnabledProperties ( ) . isEmpty ( ) )
assertNull ( editor )
assertNotNull ( info )
assertEquals ( TYPE_LUCENE , sr . getProperty ( "type" ) )
assertEquals ( LoggingInfoStream . INSTANCE , InfoStream . getDefault ( ) )
assertNotNull ( editorProvider . getExtractedTextCache ( ) . getExtractedTextProvider ( ) )
assertTrue ( editorProvider . getExtractedTextCache ( ) . isAlwaysUsePreExtractedCache ( ) )
assertNull ( sr )
assertThat ( explain ( "select [jcr:path] from [nt:base] where [propa] = 'foo'" ) , containsString ( "lucene:test1" ) )
assertThat ( explain ( query ) , containsString ( "lucene:test1" ) )
assertArrayEquals ( testData , IOUtils . toByteArray ( loader . openResource ( "foo" ) ) )
assertEquals ( 1 , executionCount . get ( ) )
assertEquals ( f1 , f2 )
assertFalse ( dir . isEmpty ( ) )
assertEquals ( ( long ) blobSize * ( dataSize - 1 ) , input . length ( ) )
assertEquals ( fileSize , dir . fileLength ( fileName ) )
assertTrue ( queue . add ( LuceneDoc . forDelete ( "/oak:index/fooIndex" , "bar" ) ) )
assertEquals ( 1 , index . getPrimaryReaderForTest ( ) . numDocs ( ) )
assertTrue ( Iterables . isEmpty ( ( ( IndexedPaths ) builder2 . build ( ) ) ) )
assertNull ( indexFactory . createIndex ( idxDefn ) )
assertNotSame ( readers2 , readers3 )
assertThat ( explain ( query ) , containsString ( "lucene:test" ) )
assertThat ( explain ( query ) , containsString ( "lucene:test" ) )
assertThat ( explain ( query ) , containsString ( "traverse" ) )
assertThat ( copyOf ( bs . getOldBuckets ( ) ) , empty ( ) )
assertThat ( copyOf ( bs . getOldBuckets ( ) ) , empty ( ) )
assertThat ( query ( f , "foo" ) , containsInAnyOrder ( "/a" ) )
assertThat ( ImmutableList . copyOf ( paths ) , containsInAnyOrder ( "/a" ) )
assertThat ( query ( propName , newString ( "bar" ) ) , containsInAnyOrder ( "/a" ) )
assertThat ( query ( "foo" , newString ( "bar" ) ) , containsInAnyOrder ( "/a" ) )
assertEquals ( CONSTRAINT , e . getType ( ) )
assertEquals ( CONSTRAINT , e . getType ( ) )
assertThat ( copyOf ( builder . getChildNodeNames ( ) ) , containsInAnyOrder ( "a" , "b" ) )
assertTrue ( readers . isEmpty ( ) )
assertNotNull ( facetsConfig )
assertFalse ( NodeStateUtils . getNode ( state , "/indexRules/nt:file/properties" ) . exists ( ) )
assertEquals ( expectedTokens . get ( i ) , token )
assertEquals ( expectedTokens . get ( i ) , token )
assertEquals ( expectedTokens . get ( i ) , token )
assertFalse ( writer . close ( 0 ) )
assertTrue ( writer . close ( 0 ) )
assertThat ( w . getConfig ( ) . getMergeScheduler ( ) , instanceOf ( ConcurrentMergeScheduler . class ) )
assertTrue ( sortStrategy instanceof TraverseWithSortStrategy )
assertEquals ( flatFile , flatFileList . get ( 0 ) )
assertEquals ( "/a" , a . getPath ( ) )
fail ( "Adding null must throw IllegalArgumentException" )
assertNotNull ( blobId )
assertEquals ( "bar" , p2 . getProperty ( "foo" ) )
assertNotNull ( fixture . getBlobStore ( ) )
assertNotNull ( opts . getCommonOpts ( ) )
assertNotNull ( is )
assertTrue ( EqualsDiff . equals ( builder . getNodeState ( ) , nodeState2 ) )
assertEquals ( "Missing tika parser dependencies, use --ignore-missing-tika-dep to force continue" , errContent . toString ( "UTF-8" ) . trim ( ) )
assertTrue ( config1 == config2 )
assertEquals ( "Failed to execute test: " + testCaseName , expectedIndexes . toString ( ) , buildIndexes . toString ( ) )
assertEquals ( new Revision ( i , 0 , 1 ) , map . get ( Path . fromString ( "/some/test/path/node-" + i ) ) )
assertEquals ( 2 , files . count ( ) )
assertTrue ( output . contains ( "Last Successful Run" ) )
assertEquals ( client1 , client2 )
assertTrue ( exists ( index ) )
assertNull ( planner . getPlan ( ) )
assertNotNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNotNull ( planner . getPlan ( ) )
assertNotNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertNotNull ( planner . getPlan ( ) )
assertNull ( planner . getPlan ( ) )
assertThat ( counter . get ( ) , is ( lessThanOrEqualTo ( 1 ) ) )
assertNull ( cache . getCacheStats ( ) )
assertNull ( text )
assertNull ( text )
assertNotEquals ( seed1 , seed2 )
assertTrue ( ! idxDefn . getApplicableIndexingRule ( TestUtil . NT_TEST ) . getNullCheckEnabledProperties ( ) . isEmpty ( ) )
assertTrue ( extractor . getTikaConfig ( ) . getServiceLoader ( ) . isDynamic ( ) )
assertNotEquals ( IndexSelectionPolicy . TAG , builder . build ( ) . getString ( IndexConstants . INDEX_SELECTION_POLICY ) )
assertEquals ( 0L , estimate )
assertTrue ( currentMSE <= mse )
assertTrue ( EqualsDiff . equals ( state , NodeStateCloner . cloneVisibleState ( state ) ) )
assertEquals ( "y" , test . getProperty ( "a/foo" ) . getString ( ) )
assertFalse ( nullLocation . exists ( ) )
assertEquals ( "null" , nullLocation . getName ( ) )
assertTrue ( propertyLocation . exists ( ) )
assertEquals ( root . getTree ( CHILD_PATH ) . getProperty ( propertyLocation . getName ( ) ) , propertyLocation . getProperty ( ) )
assertTrue ( nodeLocation . exists ( ) )
assertEquals ( child , nodeLocation . getTree ( ) )
assertTrue ( nodeLocation . remove ( ) )
assertFalse ( nodeLocation . remove ( ) )
assertFalse ( location . remove ( ) )
assertEquals ( test . path , test . type , typeProvider . getType ( mockTree ( test . path , true ) ) )
assertEquals ( NT_OAK_UNSTRUCTURED , TreeUtil . getPrimaryTypeName ( child , mock ( LazyValue . class ) ) )
assertEquals ( CHILD_PATH , t . getPath ( ) )
assertEquals ( CHILD_PATH , t . getPath ( ) )
assertEquals ( z . getPath ( ) , TreeUtil . getOrAddChild ( rootTree , z . getName ( ) , NT_OAK_UNSTRUCTURED ) . getPath ( ) )
assertTrue ( TreeUtil . getEffectiveType ( rootTree . getChild ( "x" ) , typeRoot ) . isEmpty ( ) )
assertEquals ( ImmutableList . of ( ) , TreeUtil . getEffectiveType ( mockTree ( "/anotherTree" , rootTree , false , "rep:NonExistingType" ) , typeRoot ) )
assertEquals ( NAME , compositeConfiguration . getName ( ) )
assertNull ( compositeConfiguration . getDefaultConfig ( ) )
assertEquals ( params , base . getParameters ( ) )
assertArrayEquals ( testArray , options . getConfigValue ( "test" , null , String [ ] . class ) )
assertNull ( options . get ( "test" ) )
assertTrue ( ConfigurationParameters . EMPTY . keySet ( ) . isEmpty ( ) )
assertFalse ( Context . DEFAULT . definesLocation ( TreeLocation . create ( tree ) ) )
assertTrue ( securityProvider . getConfiguration ( AuthorizationConfiguration . class ) instanceof OpenAuthorizationConfiguration )
assertEquals ( "org.apache.jackrabbit.oak" , configuration . getName ( ) )
assertTrue ( configuration . getProtectedItemImporters ( ) . isEmpty ( ) )
assertFalse ( loginModule . logout ( ) )
assertTrue ( loginModule . logout ( null , Collections . emptySet ( ) ) )
assertTrue ( loginModule . abort ( ) )
assertTrue ( loginModule . abort ( ) )
assertTrue ( lm . getCredentials ( ) instanceof TestCredentials )
assertNull ( lm . getCredentials ( ) )
assertNull ( lm . getCredentials ( ) )
assertNull ( lm . getCredentials ( ) )
assertNull ( lm . getCredentials ( ) )
assertNull ( loginModule . getSharedPreAuthLogin ( ) )
assertNull ( loginModule . getSharedPreAuthLogin ( ) )
assertNotNull ( root )
assertNull ( lm . getRoot ( ) )
assertNull ( lm . getRoot ( ) )
assertNull ( loginModule . getRoot ( ) )
assertNull ( loginModule . getSecurityProvider ( ) )
assertNull ( loginModule . getRoot ( ) )
assertNull ( loginModule . getSecurityProvider ( ) )
assertNull ( loginModule . getWhiteboard ( ) )
assertNull ( loginModule . getWhiteboard ( ) )
assertNull ( loginModule . getWhiteboard ( ) )
assertNull ( loginModule . getWhiteboard ( ) )
assertNull ( loginModule . getUserManager ( ) )
assertNull ( loginModule . getUserManager ( ) )
assertNull ( loginModule . getUserManager ( ) )
assertEquals ( um , loginModule . getUserManager ( ) )
assertNull ( loginModule . getUserManager ( ) )
assertNull ( loginModule . getUserManager ( ) )
assertNull ( loginModule . getUserManager ( ) )
assertTrue ( principals . isEmpty ( ) )
assertNull ( authInfo . getUserID ( ) )
assertEquals ( USER_ID , authInfo . getUserID ( ) )
assertTrue ( guestLoginModule . abort ( ) )
assertNull ( ctx . getSubject ( ) )
assertEquals ( subject , ctx . getSubject ( ) )
assertEquals ( "id" , new PreAuthenticatedLogin ( "id" ) . getUserId ( ) )
assertEquals ( ImmutableSet . of ( SystemPrincipal . INSTANCE ) , SystemSubject . INSTANCE . getPrincipals ( ) )
assertNull ( cb . getContentRepository ( ) )
assertNull ( cb . getSecurityProvider ( ) )
assertNull ( cb . getWorkspaceName ( ) )
assertEquals ( USER_ID , credentials . getUserId ( ) )
assertFalse ( credentialsSupport . setAttributes ( new Credentials ( ) { } , ImmutableMap . of ( "a" , "value" ) ) )
assertEquals ( TokenConfiguration . NAME , composite . getName ( ) )
assertTrue ( tp instanceof CompositeTokenProvider )
assertNull ( composite . getTokenInfo ( "any" ) )
assertEquals ( ImmutableSet . of ( TOKEN_ATTRIBUTE_EXPIRY , TOKEN_ATTRIBUTE_KEY ) , TokenConstants . TOKEN_PROPERTY_NAMES )
assertEquals ( msg , e . getMessage ( ) )
assertTrue ( ace . getRestrictions ( ) . isEmpty ( ) )
assertEquals ( nameValue , val )
assertNull ( vs )
assertTrue ( ace . getRestrictions ( ) . isEmpty ( ) )
assertEquals ( ace , ace )
assertNotEquals ( ace , ace2 )
assertNotEquals ( ace , ace2 )
assertNotEquals ( ace , ace2 )
assertNotEquals ( ace , ace2 )
assertNotSame ( root , createAccessControlManager ( root , getNamePathMapper ( ) ) . getLatestRoot ( ) )
assertNotNull ( acMgr . getTree ( null , Permissions . ALL , false ) )
assertEquals ( privilege , p )
assertArrayEquals ( allPrivileges , acMgr . getPrivileges ( testPath ) )
assertEquals ( "Grants read access on configured trees." , ReadPolicy . INSTANCE . getName ( ) )
assertTrue ( emptyProvider . getPrivileges ( tree ) . isEmpty ( ) )
assertEquals ( ImmutableSet . of ( NT_REP_PERMISSIONS , NT_REP_PERMISSION_STORE ) , PermissionConstants . PERMISSION_NODETYPE_NAMES )
assertTrue ( names . isEmpty ( ) )
assertEquals ( Permissions . PERMISSION_NAMES . get ( Permissions . ALL ) , str )
assertEquals ( expected , Sets . newHashSet ( Splitter . on ( ',' ) . split ( Permissions . getString ( key ) ) ) )
assertFalse ( Permissions . getString ( p ) , Permissions . respectParentPermissions ( p ) )
Permissions . PERMISSION_NAMES . forEach ( ( key , value ) -> assertEquals ( key . longValue ( ) , Permissions . getPermissions ( value ) ) )
assertTrue ( restrictions . isEmpty ( ) )
assertTrue ( rp instanceof CompositePattern )
assertEquals ( name , definition . getName ( ) )
assertEquals ( createProperty ( name , value , type ) , restriction . getProperty ( ) )
assertEquals ( restriction . hashCode ( ) , new RestrictionImpl ( createProperty ( name , value , type ) , isMandatory ) . hashCode ( ) )
assertTrue ( pMgr instanceof PrincipalManagerImpl )
assertFalse ( pp instanceof CompositePrincipalProvider )
assertTrue ( pMgr instanceof PrincipalManagerImpl )
assertTrue ( pp instanceof CompositePrincipalProvider )
assertNull ( cpp . getPrincipal ( TestPrincipalProvider . UNKNOWN . getName ( ) ) )
assertTrue ( principalProvider . getPrincipals ( "userId" ) . isEmpty ( ) )
assertEquals ( EveryonePrincipal . NAME , everyone . getName ( ) )
assertEquals ( "name" , principal . getName ( ) )
assertEquals ( principal , p )
assertEquals ( EveryonePrincipal . getInstance ( ) , principalMgr . getPrincipal ( EveryonePrincipal . NAME ) )
assertTrue ( "findPrincipals does not find principal with filter '" + EveryonePrincipal . NAME + '\'' , Iterators . contains ( it , EveryonePrincipal . getInstance ( ) ) )
assertFalse ( principalMgr . findPrincipals ( unknownHint , PrincipalManager . SEARCH_TYPE_NOT_GROUP ) . hasNext ( ) )
assertNull ( pp . getItemBasedPrincipal ( "/some/path" ) )
assertEquals ( "system" , SystemPrincipal . INSTANCE . getName ( ) )
assertEquals ( "name" , def . getName ( ) )
assertEquals ( readBits . asPropertyState ( "anyName" ) , propertyState )
assertEquals ( bits . unmodifiable ( ) , JcrAllUtil . getPrivilegeBits ( propState , bitsProvider ) )
assertEquals ( DYNAMIC_ALL_PROPERTY , JcrAllUtil . asPropertyState ( "anyName" , ALL_BITS , bitsProvider ) )
assertNotNull ( bitsProvider . getPrivilegesTree ( ) )
assertEquals ( bits1 , bits2 )
assertTrue ( names . isEmpty ( ) )
assertTrue ( names . isEmpty ( ) )
assertEquals ( ImmutableSet . copyOf ( AGGREGATE_PRIVILEGES . get ( JCR_READ ) ) , ImmutableSet . copyOf ( bitsProvider . getAggregatedPrivilegeNames ( JCR_READ ) ) )
assertEquals ( expected , ImmutableSet . copyOf ( result ) )
assertEquals ( expected , ImmutableSet . copyOf ( result ) )
assertTrue ( Iterables . isEmpty ( result ) )
assertEquals ( expected , ImmutableSet . copyOf ( result ) )
assertEquals ( expected , ImmutableSet . copyOf ( result ) )
assertEquals ( expected , ImmutableSet . copyOf ( result ) )
assertTrue ( PrivilegeBits . EMPTY . isEmpty ( ) )
assertEquals ( next , PrivilegeBits . getInstance ( tmp ) )
assertEquals ( BUILT_IN . get ( JCR_READ ) , PrivilegeBits . getInstance ( readPrivTree ) )
assertEquals ( JCR_LIFECYCLE_MANAGEMENT , PrivilegeUtil . getOakName ( Privilege . JCR_LIFECYCLE_MANAGEMENT , mapper ) )
assertTrue ( PrivilegeUtil . getOakNames ( null , mapper ) . isEmpty ( ) )
assertEquals ( Text . escapeIllegalJcrChars ( hint ) , AuthorizableNodeName . DEFAULT . generateNodeName ( hint ) )
assertEquals ( "id" , creds . getUserId ( ) )
assertTrue ( gr . removed . contains ( user ) )
assertTrue ( cap . getAuthorizableActions ( securityProvider ) . isEmpty ( ) )
assertEquals ( ImmutableList . of ( TestAction . INSTANCE , TestAction . INSTANCE ) , new CompositeActionProvider ( ImmutableList . of ( aap , aap2 ) ) . getAuthorizableActions ( securityProvider ) )
assertNull ( f . get ( action ) )
assertFalse ( PasswordUtil . isSame ( PasswordUtil . buildPasswordHash ( "pw" ) , ( String ) null ) )
test . forEach ( ( key , value ) -> assertEquals ( value , UserUtil . isType ( createTree ( key ) , AuthorizableType . GROUP ) ) )
test . forEach ( ( ntName , expected ) -> assertEquals ( ntName , expected , UserUtil . getType ( createTree ( ntName ) ) ) )
assertNull ( UserUtil . getType ( createTree ( ntName ) ) )
assertEquals ( "id" , UserUtil . getAuthorizableId ( createTree ( ntName , "id" ) ) )
assertEquals ( "name" , nodeInfo . getName ( ) )
assertEquals ( "string" , propInfo . getName ( ) )
assertEquals ( tv . getValue ( PropertyType . STRING ) , propInfo . getValue ( PropertyType . STRING ) )
assertNull ( rct . get ( "old" ) )
assertEquals ( "v1" , split . getRoot ( ) . getChildNode ( "foo" ) . getChildNode ( "bar" ) . getString ( "version" ) )
assertEquals ( "v1" , split . getRoot ( ) . getChildNode ( "foo" ) . getChildNode ( "bar" ) . getString ( "version" ) )
assertEquals ( "v1" , base . getRoot ( ) . getChildNode ( "foo" ) . getChildNode ( "bar" ) . getString ( "version" ) )
assertEquals ( lines , reverse ( entries ) )
assertNotNull ( persistence )
assertNotNull ( persistence )
assertNotNull ( persistence )
assertNotNull ( persistence )
assertNotNull ( persistence )
assertEquals ( entries , reader )
assertEquals ( entries , reader )
assertNull ( store . retrieve ( cp ) )
assertNull ( compactor . compact ( nodeStore . getRoot ( ) , Canceller . newCanceller ( ) . withCondition ( "reason" , ( ) -> true ) ) )
assertEquals ( fileStore . getRevisions ( ) . getHead ( ) , fileStore . getRevisions ( ) . getPersistedHead ( ) )
assertEquals ( HELLO_WORLD , IOUtils . toString ( blob . getNewStream ( ) , Charsets . UTF_8 ) )
assertFalse ( EMPTY_STORE . containsSegment ( SegmentId . NULL ) )
assertEquals ( entries , iterated )
assertFalse ( set . contains ( k ) )
assertEquals ( 1 , reference )
assertEquals ( first , second )
assertEquals ( 0 , root . getChildNodeCount ( 1 ) )
assertEquals ( loader . apply ( offset ) , x )
assertEquals ( hits , cacheStats . getHitCount ( ) )
assertEquals ( ( KEYS - ( double ) hits ) / KEYS , cacheStats . getMissRate ( ) , Double . MIN_VALUE )
assertEquals ( 0 , cacheStats . getLoadExceptionCount ( ) )
assertEquals ( 0 , cacheStats . getAverageLoadPenalty ( ) , Double . MIN_VALUE )
assertEquals ( KEYS , cacheStats . estimateCurrentWeight ( ) )
assertEquals ( before , after )
assertEquals ( before , after )
assertEquals ( before , after )
assertNotNull ( state . getProperty ( "jcr:primaryType" ) )
assertNotNull ( state . getProperty ( "jcr:mixinTypes" ) )
assertEquals ( rootId , res . get ( ) )
assertEquals ( before , after )
assertNotEquals ( before , after )
assertTrue ( Sets . symmetricDifference ( state . blobsPresent , existingAfterGC ) . isEmpty ( ) )
assertTrue ( Sets . symmetricDifference ( state . blobsPresent , existingAfterGC ) . isEmpty ( ) )
assertTrue ( Sets . symmetricDifference ( state . blobsPresent , existingAfterGC ) . isEmpty ( ) )
assertEquals ( map . getRecordId ( ) , mapInfo . mapId )
assertThat ( builder . toString ( ) , containsString ( "binariesInlineThreshold" ) )
assertEquals ( store . getRevisions ( ) . getHead ( ) , ro . getRevisions ( ) . getHead ( ) )
fail ( "should not be able to open 2 stores on the same path" )
assertEquals ( newGCGeneration ( 1 , 2 , false ) , in . read ( ) . getGcGeneration ( ) )
assertEquals ( 3 , Manifest . load ( manifest ) . getStoreVersion ( 0 ) )
assertEquals ( Type . BINARY , property . getType ( ) )
assertTrue ( Iterables . contains ( n . getChildNodeNames ( ) , "references" ) )
assertEquals ( MissingSegmentNode . class , SegmentNode . newSegmentNode ( backend , "s" ) . getClass ( ) )
assertEquals ( DataSegmentNode . class , SegmentNode . newSegmentNode ( backend , "s" ) . getClass ( ) )
assertEquals ( BulkSegmentNode . class , SegmentNode . newSegmentNode ( backend , "s" ) . getClass ( ) )
assertEquals ( newGCGeneration ( 1 , 2 , false ) , newGCGeneration ( entries [ 0 ] ) )
assertEquals ( 0 , tarFiles . size ( ) )
assertNull ( readSegment ( randomUUID ( ) ) )
assertEquals ( expected , graph )
assertEquals ( sizeAfter - sizeBefore , writtenAfter - writtenBefore )
assertEquals ( 2 , new IndexV1 ( buffer ) . count ( ) )
assertEquals ( 2 , new IndexV2 ( buffer ) . count ( ) )
fail ( "In-memory binaries should not be downloaded" )
assertEquals ( newGetBlobRequest ( "clientId" , "blobId" ) , message )
assertEquals ( newGetHeadRequest ( "clientId" ) , message )
assertEquals ( expected , buffer )
assertEquals ( newGetReferencesRequest ( "clientId" , "segmentId" ) , message )
assertEquals ( expected , buffer )
assertEquals ( newGetSegmentRequest ( "clientId" , "segmentId" ) , message )
assertEquals ( expected , buffer )
assertNull ( extractMessageFrom ( "wrong" ) )
assertEquals ( "message" , extractMessageFrom ( "Standby-CMD@:message" ) )
assertEquals ( "client" , extractClientFrom ( "Standby-CMD@client:message" ) )
assertEquals ( "clientId" , request . getClientId ( ) )
assertEquals ( recordId , response . getHeadRecordId ( ) )
assertEquals ( match , new ClientIpFilter ( parseFilters ( ) ) . isAllowed ( createAddress ( ) ) )
assertNull ( r . readBlob ( "id" ) )
assertNull ( r . readBlob ( "id" ) )
assertEquals ( store . getRevisions ( ) . getPersistedHead ( ) . toString ( ) , reader . readHeadRecordId ( ) )
assertNull ( reader . readReferences ( randomUUID ( ) . toString ( ) ) )
assertEquals ( "test" , observer . getID ( ) )
assertEquals ( "127.0.0.1" , observer . communicationPartners . get ( 0 ) . getRemoteAddress ( ) )
assertEquals ( "request" , observer . communicationPartners . get ( 0 ) . getLastRequest ( ) )
assertNotNull ( observer . communicationPartners . get ( 0 ) . getLastSeen ( ) )
assertEquals ( 1 , observer . communicationPartners . get ( 0 ) . getTransferredBinaries ( ) )
assertEquals ( 0 , trace . size ( ) )
assertEquals ( test , roundtripped )
assertNotNull ( remoteSolrServerProvider )
assertNotNull ( embeddedSolrServerProvider )
assertNotNull ( nodeStateConfiguration . getCatchAllField ( ) )
assertNotNull ( solrServer )
assertThat ( "NodeStore registered, but it should not have been" , ctx . getService ( NodeStore . class ) , nullValue ( ) )
assertNull ( "Not all expected mounts have been provided" , provider )
assertTrue ( super . ds . create ( Collection . JOURNAL , Collections . singletonList ( up ) ) )
assertNotNull ( desc . get ( "type" ) )
assertEquals ( blobSize , mk . getLength ( id ) )
assertFalse ( ns . getRoot ( ) . hasProperty ( "p" ) )
assertThrows ( IllegalArgumentException . class , ( ) -> checkpoints . create ( ONE_HOUR , info , r ) )
assertFalse ( createInactive ( true ) . isInvisible ( ) )
assertTrue ( info . getLeaseEndTime ( ) < clock . getTime ( ) )
assertEquals ( LeaseCheckMode . STRICT , newClusterNodeInfo ( 0 ) . getLeaseCheckMode ( ) )
assertEquals ( "{\"branchVisible\":{},\"regular\":{},\":childNodeCount\":2}" , nodes )
assertThat ( e . getMessage ( ) , containsString ( "already added" ) )
assertNotNull ( op )
assertEquals ( new RevisionVector ( ) , c . getStartRevisions ( ) )
org . junit . Assert . assertEquals ( "counter property not updated as expected" , Integer . toString ( workers ) , val )
assertEquals ( CommitFailedException . MERGE , cfe . getType ( ) )
assertEquals ( "Wrong property value after merge" , expectedNode , mergedNode )
assertEquals ( "^\"/test\":{}" , jsop )
assertEquals ( branch , rebased )
assertEquals ( branch , rebased )
assertEquals ( 198 , state . getMemory ( ) )
assertEquals ( 2 , ns . getPropertyCount ( ) )
assertNotNull ( r )
assertEquals ( keepAlive , config . socketKeepAlive ( ) )
assertTrue ( jobScheduled )
assertEquals ( LeaseCheckMode . STRICT , dns . getClusterInfo ( ) . getLeaseCheckMode ( ) )
assertTrue ( nodeStore . renewClusterIdLease ( ) )
assertEquals ( 5 , getMeter ( DocumentNodeStoreStats . BGR_NUM_CHANGES_RATE ) . getCount ( ) )
assertEquals ( 0 , counter . get ( ) )
assertTrue ( "No Throttling wrapper has been created by default" , store instanceof MemoryDocumentStore )
assertTrue ( ns . getNodeChildrenCacheStats ( ) . getElementCount ( ) < 2 * DocumentMK . UPDATE_LIMIT )
assertTrue ( ns . getNodeCacheStats ( ) . getElementCount ( ) < 2 * NUM_CHILDREN )
assertEquals ( 1 , ws . count )
assertNotNull ( doc )
assertThat ( e . getMessage ( ) , containsString ( "failed to update the lease" ) )
assertThat ( e . getMessage ( ) , containsString ( "lease end" ) )
assertThrows ( IllegalStateException . class , ( ) -> store . checkpoint ( 60000 , Collections . emptyMap ( ) ) )
assertEquals ( path , doc . getMainPath ( ) )
assertTrue ( "document with " + id + " not created" , success )
assertEquals ( s , v . toString ( ) )
assertEquals ( 4 , sort . getSize ( ) )
assertEquals ( changes , Diff . fromString ( diff . asString ( ) ) . getChanges ( ) )
assertEquals ( diff , diff2 )
assertEquals ( "r3-0-1/foo/bar@r7-0-1" , key . asString ( ) )
assertEquals ( expected , key )
assertEquals ( 2 , docs )
assertTrue ( Sets . symmetricDifference ( state . blobsPresent , existingAfterGC ) . isEmpty ( ) )
assertTrue ( Sets . symmetricDifference ( state . blobsPresent , existingAfterGC ) . isEmpty ( ) )
assertTrue ( Sets . symmetricDifference ( state . blobsAdded , existingAfterGC ) . isEmpty ( ) )
assertTrue ( Sets . symmetricDifference ( state . blobsPresent , existingAfterGC ) . isEmpty ( ) )
assertTrue ( Sets . symmetricDifference ( state . blobsPresent , existingAfterGC ) . isEmpty ( ) )
assertEquals ( expected , paths )
assertEquals ( 140 , uncommittedRevisions )
assertEquals ( 140 , uncommittedRevisions )
assertFalse ( tds . paths . contains ( "/oak:index/prop-b/b1" ) )
assertEquals ( expected , paths )
assertTrue ( store . getRoot ( ) . hasChildNode ( "child" ) )
assertEquals ( rv , rvFromStr )
assertFalse ( "DocumentNodeStore must fail when server time difference is too high" , success )
assertFalse ( sweepRev . equals ( ns2 . getSweepRevisions ( ) ) )
assertEquals ( t , ti )
assertEquals ( t , new TimeInterval ( start , start + 2 ) )
assertThat ( processingTime . get ( ) , greaterThanOrEqualTo ( DELAY_MS / 2 ) )
assertNull ( store . find ( Collection . NODES , testId ) )
assertEquals ( 0 , gc ( ) . get ( ) . splitDocGCCount )
assertEquals ( 1 , store . findVersionGC . get ( ) )
assertEquals ( 0 , deletedOnceCountCalls . get ( ) )
assertEquals ( "-\"a\"^\"b\":{}+\"c\":{}" , w . toString ( ) )
assertTrue ( registry . getBundlors ( ) . isEmpty ( ) )
assertFalse ( bundlor . exists ( ) )
assertThat ( e . getMessage ( ) , containsString ( "ConflictException" ) )
assertThat ( e . getMessage ( ) , containsString ( "ConflictException" ) )
assertThat ( e . getMessage ( ) , containsString ( "ConflictException" ) )
assertTrue ( result . isEmpty ( ) )
assertFalse ( pr . getPath ( ) . toString ( ) . contains ( "jcr:content/renditions" ) )
assertEquals ( updated . getModCount ( ) , cache . get ( ID , ( ) -> updated ) . getModCount ( ) )
assertEquals ( initialCacheSizeC1 + totalPaths - 2 , size ( ds ( c1 ) . getNodeDocumentCache ( ) . keys ( ) ) )
assertTrue ( configuredCompressor . indexOf ( CollectionCompressor . SNAPPY . getName ( ) ) > 0 )
assertNull ( builder . getDocStoreThrottlingFeature ( ) )
assertTrue ( builder . createMissingLastRevSeeker ( ) instanceof MongoMissingLastRevSeeker )
assertTrue ( status . getVersion ( ) . matches ( "^\\d+\\.\\d+\\.\\d+$" ) )
assertEquals ( 150 , sizeLimit )
assertEquals ( 150 , sizeLimit )
assertEquals ( 150 , sizeLimit )
assertEquals ( Integer . MAX_VALUE , sizeLimit )
assertEquals ( Integer . MAX_VALUE , sizeLimit )
assertEquals ( Integer . MAX_VALUE , sizeLimit )
assertThat ( docs , is ( empty ( ) ) )
assertEquals ( emptyList ( ) , putActions )
assertEquals ( empty , DataTypeUtil . revisionVectorFromBuffer ( rb ) )
assertEquals ( p , DataTypeUtil . pathFromBuffer ( rb ) )
assertEquals ( p , DataTypeUtil . pathFromBuffer ( rb ) )
assertEquals ( p , DataTypeUtil . pathFromBuffer ( rb ) )
assertEquals ( expected , DataTypeUtil . pathRevFromBuffer ( rb ) )
assertEquals ( expected , DataTypeUtil . namePathRevFromBuffer ( rb ) )
assertEquals ( requests , stats . getCount ( ) )
assertNull ( doc . getModified ( ) )
assertTrue ( cnt > 0 )
assertFalse ( NodeStateUtils . getNode ( secondaryRoot ( ) , "/a/c" ) . exists ( ) )
assertFalse ( customizer . getLogs ( ) . isEmpty ( ) )
assertEquals ( k1 , k2 )
assertEquals ( test , roundtripped )
assertFalse ( "Throttling is disabled explicitly" , throttlingEnabled )
assertTrue ( "Throttling is enabled via configuration" , throttlingEnabled )
assertTrue ( "Throttling is enabled via Feature Toggle" , throttlingEnabled )
assertNull ( Utils . max ( null , null ) )
assertThat ( customizer . getLogs ( ) , empty ( ) )
assertTrue ( closed . get ( ) )
assertEquals ( Type . NAME , nodeState2 . getProperty ( JcrConstants . JCR_PRIMARYTYPE ) . getType ( ) )
assertEquals ( expectedOrder , childNames )
assertEquals ( x . getBaseState ( ) , x . getNodeState ( ) )
assertFalse ( base . builder ( ) . remove ( ) )
assertEquals ( source , builder . getPropertyState ( ) )
assertEquals ( nameProperty , namePropertyFromValue )
assertEquals ( expected , actual )
assertTrue ( new MoveTracker ( ) . isEmpty ( ) )
assertTrue ( observers . isEmpty ( ) )
assertEquals ( 0 , session . getNode ( "/libs/sling/xss/config.xml/jcr:content" ) . getProperty ( "jcr:data" ) . getLength ( ) )
assertEquals ( 1 , customLogs . getLogs ( ) . size ( ) )
assertNotNull ( blobStore )
assertEquals ( "LoopbackBlobStore" , factory . toString ( ) )
assertEquals ( "123aaa" , stripValue ( "B\"123aaa\"" ) )
assertEquals ( "123aaa" , stripValue ( "123aaa" ) )
