assertEquals ( "Counts should match" , 9L , cnt )
assertEquals ( 3 , count )
assertEquals ( "Counts should match" , 5727L , cnt )
assertTrue ( e . getMessage ( ) . contains ( "Could not open sheet " ) )
assertNull ( results )
assertEquals ( HDF5Utils . getNameFromPath ( path1 ) , "group1" )
assertEquals ( HDF5Utils . getNameFromPath ( emptyPath ) , "" )
assertEquals ( HDF5Utils . getNameFromPath ( rootPath ) , "" )
assertTrue ( e . getMessage ( ) . contains ( "Error reading HTTPD file " ) )
assertEquals ( 3 , count )
assertEquals ( 2 , count )
assertEquals ( 2 , count )
assertEquals ( 1 , count )
MatcherAssert . assertThat ( e . getVerboseMessage ( ) , containsString ( "Both 'snapshotId' and 'snapshotAsOfTime' cannot be specified" ) )
assertEquals ( 2 , count )
assertEquals ( 2 , count )
assertEquals ( 1 , count )
assertEquals ( "Counts should match" , 2 , cnt )
assertTrue ( e . getMessage ( ) . contains ( "Regex property is required" ) )
assertEquals ( 2 , queryBuilder ( ) . sql ( "SELECT * FROM cp.`emptylines.ltsv`" ) . run ( ) . recordCount ( ) )
assertTrue ( e . getMessage ( ) . contains ( "DATA_READ ERROR: Empty key detected at line [0] position [49]" ) )
assertEquals ( 200000 , resultListener . getRowCount ( ) )
assertEquals ( "Counts should match" , 1L , cnt )
assertEquals ( "Counts should match" , 1 , cnt )
assertEquals ( "Counts should match" , 6 , cnt )
assertNull ( table )
assertEquals ( "Counts should match" , 50L , cnt )
assertEquals ( "Counts should match" , 25L , cnt )
assertEquals ( 6L , result )
assertEquals ( "Counts should match" , 3L , cnt )
assertThat ( e . getMessage ( ) , containsString ( "Object 'ut_cassandra' not found" ) )
assertEquals ( 25 , count )
assertThat ( druidScanSpec . getFilter ( ) . toJson ( ) ) . isEqualTo ( "{\"type\":\"selector\",\"dimension\":\"some field\",\"value\":\"some value\"}" )
assertThat ( druidScanSpec . getFilter ( ) . toJson ( ) ) . isEqualTo ( "{\"type\":\"not\",\"field\":{\"type\":\"selector\",\"dimension\":\"some field\",\"value\":\"some value\"}}" )
assertThat ( druidScanSpec . getFilter ( ) . toJson ( ) ) . isEqualTo ( "{\"type\":\"bound\",\"dimension\":\"some field\",\"lower\":\"1\",\"lowerStrict\":true,\"ordering\":\"numeric\"}" )
assertThat ( druidScanSpec . getFilter ( ) . toJson ( ) ) . isEqualTo ( "{\"type\":\"bound\",\"dimension\":\"some field\",\"upper\":\"some value\",\"ordering\":\"lexicographic\"}" )
assertThat ( druidScanSpec . getFilter ( ) . toJson ( ) ) . isEqualTo ( "{\"type\":\"bound\",\"dimension\":\"some field\",\"upper\":\"some value\",\"upperStrict\":true,\"ordering\":\"lexicographic\"}" )
assertThat ( e . getMessage ( ) , containsString ( "EXECUTION_ERROR ERROR: Field full_name123 not defined for employee" ) )
assertTrue ( e . getMessage ( ) . contains ( "Tab not found at index 5" ) )
assertTrue ( insertResults . succeeded ( ) )
assertEquals ( "Expected and actual row count should match" , expectedRowCount , actualRowCount )
assertEquals ( "Expected and actual row count should match" , 2 , actualRowCount )
assertEquals ( 0 , cache . addOrGet ( columns ) )
assertEquals ( 0 , cache . addOrGet ( Lists . newArrayList ( columns ) ) )
assertTrue ( e . getMessage ( ) . contains ( "API Query with URL Parameters must be populated." ) )
assertNull ( results )
assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( "FUNCTION ERROR: nope is not a valid plugin." ) )
assertEquals ( 6 , count )
assertTrue ( e . getMessage ( ) . contains ( "Default URL parameters must have a value." ) )
assertTrue ( e . getMessage ( ) . contains ( "You do not have valid credentials for this API." ) )
assertEquals ( 4 , queryBuilder ( ) . physical ( plan ) . run ( ) . recordCount ( ) )
assertEquals ( 5 , queryBuilder ( ) . physical ( plan ) . run ( ) . recordCount ( ) )
assertEquals ( 4 , queryBuilder ( ) . physical ( plan ) . run ( ) . recordCount ( ) )
assertEquals ( 4 , queryBuilder ( ) . physical ( plan ) . run ( ) . recordCount ( ) )
assertEquals ( 4 , queryBuilder ( ) . physical ( plan ) . run ( ) . recordCount ( ) )
assertThat ( e . getMessage ( ) , containsString ( "Object 'mysql' not found" ) )
assertTrue ( e . getMessage ( ) . contains ( "VALIDATION ERROR: Table [none_shall_pass] not found" ) )
assertTrue ( e . getMessage ( ) . contains ( "VALIDATION ERROR: Table [none_shall_pass] not found" ) )
assertTrue ( e . getMessage ( ) . contains ( "VALIDATION ERROR: Unable to create or drop objects. Schema [pg_unwritable.public] is immutable." ) )
assertTrue ( e . getMessage ( ) . contains ( "VALIDATION ERROR: Table [none_shall_pass] not found" ) )
assertTrue ( re . getMessage ( ) . contains ( "DATA_READ ERROR: Table 'invalid-topic' does not exist" ) )
assertTrue ( messageReader instanceof JsonMessageReader )
assertEquals ( 10L , mapReader . reader ( "seqNo" ) . readLong ( ) . longValue ( ) )
assertEquals ( "test_string" , mapReader . reader ( "stringKey" ) . readText ( ) . toString ( ) )
assertEquals ( queryBuilder ( ) . physical ( plan ) . run ( ) . recordCount ( ) , 11 )
assertEquals ( queryBuilder ( ) . physical ( plan ) . run ( ) . recordCount ( ) , 5 )
assertEquals ( 4 , runQuery ( query ) )
assertEquals ( 1 , queryBuilder ( ) . sql ( "SHOW TABLES LIKE '%REGION%'" ) . run ( ) . recordCount ( ) )
assertEquals ( "Counts should match" , 25 , cnt )
assertTrue ( e . getMessage ( ) . contains ( "SPL cannot be empty when querying spl table" ) )
assertEquals ( "Counts should match" , 1 , cnt )
assertEquals ( "search index=main | fields field1 | table field1" , query )
assertEquals ( "search index=main field1=\"foo\" | fields field1,field2,field3 | table field1,field2,field3" , query )
assertEquals ( "search index=main field1>5 | fields field1 | table field1" , query )
assertEquals ( "search index=main field1>=5 | fields field1 | table field1" , query )
assertEquals ( "search index=main field1<=5 | fields field1 | table field1" , query )
assertEquals ( "search index=main sourcetype=\"access_combined_wcookie\" | table *" , query )
assertEquals ( "search index=main field1=\"value1\" | table *" , query )
assertEquals ( "search index=main (sourcetype=\"access_combined_wcookie\" OR sourcetype=\"sourcetype2\" OR sourcetype=\"sourcetype3\") | table *" , query )
assertThat ( e . getMessage ( ) , containsString ( "Object 'ut_splunk' not found" ) )
assertTrue ( e . getMessage ( ) . contains ( "[BAD_DATE] is not a valid time statement. Expecting: " + Arrays . asList ( DateConversionUtils . TimeInterval . values ( ) ) ) )
assertEquals ( "J500" , result )
assertEquals ( "BASTAN" , result )
assertEquals ( "FNKS" , result )
assertEquals ( 0.5000000000000001 , result , 0.0 )
assertEquals ( 0 , result . returnCode )
assertEquals ( "Incorrect number of rows returned by query. expected:<7> but was:<5>" , ex . getMessage ( ) )
assertEquals ( "Incorrect number of rows returned by query. expected:<5> but was:<7>" , ex . getMessage ( ) )
assertEquals ( "Unexpected extra column `address` returned by query." , ex . getMessage ( ) )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Number of output rows" , expectedRecordCount , actualRecordCount )
assertEquals ( "Expected and actual row count should match" , expectedRowCount , actualRowCount )
MatcherAssert . assertThat ( e . getVerboseMessage ( ) , containsString ( "VALIDATION ERROR: Alias with given name [`abc`] already exists" ) )
MatcherAssert . assertThat ( e . getVerboseMessage ( ) , containsString ( "VALIDATION ERROR: Cannot drop public aliases for specific user" ) )
assertEquals ( 1 , recordCount )
assertEquals ( 1 , recordCount )
assertEquals ( 1 , recordCount )
assertEquals ( 1 , recordCount )
assertEquals ( 1 , recordCount )
assertEquals ( "Total of " + NUM_RECORDS + " records expected in count" , countV . getAccessor ( ) . get ( 0 ) , NUM_RECORDS )
assertTrue ( e instanceof DrillException )
assertTrue ( e instanceof DrillException )
assertTrue ( ex instanceof InvalidConnectionInfoException )
assertEquals ( DrillVersionInfo . getVersion ( ) , application . getVersion ( ) )
assertEquals ( "value mismatch" , value , actual )
assertArrayEquals ( "data mismatch" , data , actual )
assertEquals ( "entries do not match" , expected , entries . next ( ) )
assertNull ( client . putIfAbsent ( path , data ) )
assertEquals ( "Data should match" , new String ( data ) , new String ( client . putIfAbsent ( path , "new_data" . getBytes ( StandardCharsets . UTF_8 ) ) ) )
assertEquals ( "Version number should match" , version . get ( ) , registryHolder . getVersion ( ) )
assertTrue ( count > 0 )
assertEquals ( 100 , count )
assertEquals ( 200 , count )
assertEquals ( 200 , count )
assertNull ( BaseRootExec . findLeaf ( Collections . emptyList ( ) , e ) )
assertEquals ( 150 , count )
assertTrue ( topNBatch . next ( ) == RecordBatch . IterOutcome . NONE )
assertEquals ( 25 , count )
assertEquals ( 10 , count )
assertEquals ( 0 , count )
assertEquals ( 0 , count )
assertEquals ( 10 , count )
assertEquals ( 60175 , count )
assertThat ( ex . getMessage ( ) , containsString ( "Alias table and column name are required for UNNEST" ) )
assertTrue ( scanProj . projectAll ( ) )
assertNull ( creator . reader )
assertNull ( buildHandler ( RowSetTestUtils . projectNone ( ) , MOCK_ROOT_PATH , MOCK_FILE_PATH ) )
assertEquals ( expected , result . schema ( ) )
assertTrue ( e . getMessage ( ) . contains ( "wrong type" ) )
assertTrue ( e . getMessage ( ) . contains ( "wrong type" ) )
assertTrue ( e . getMessage ( ) . contains ( "wrong type" ) )
assertNull ( handler )
assertTrue ( e . getMessage ( ) . contains ( "conflict" ) )
assertTrue ( e . getMessage ( ) . contains ( "conflict" ) )
assertTrue ( e . getMessage ( ) . contains ( "conflict" ) )
assertEquals ( - 1 , result . wildcardPosn )
assertTrue ( schemaTracker instanceof ProjectionSchemaTracker )
assertEquals ( expected , tracker . internalSchema ( ) . toSchema ( ) )
assertEquals ( 50 , numOutputRecords )
assertTrue ( BatchValidator . validate ( batch . vectorAccessible ( ) ) )
assertTrue ( ov . getAccessor ( ) . get ( 3 ) > 0 )
assertFalse ( hasAssertions )
assertTrue ( e . getMessage ( ) . contains ( "column value is larger than the maximum" ) )
assertTrue ( rsReader . next ( ) )
assertTrue ( rsReader . next ( ) )
assertEquals ( 0 , vector1 . getBuffer ( ) . capacity ( ) )
assertEquals ( 2 * i , vector . getAccessor ( ) . get ( i ) )
assertEquals ( 10 + i , vector . getAccessor ( ) . get ( i ) )
assertEquals ( base + ( 2 * i ) , stringAt ( vector , i ) )
assertTrue ( e . getMessage ( ) . contains ( "overflow called" ) )
assertEquals ( "Counts should match" , 25L , cnt )
assertTrue ( "memory requirement is different" , Iterables . all ( resources . entrySet ( ) , ( e ) -> e . getValue ( ) . getMemory ( ) == 20 ) )
assertEquals ( String . valueOf ( newValue ) , changedValue )
assertEquals ( 0 , totalDataSize )
assertTrue ( ex instanceof IndexOutOfBoundsException )
assertTrue ( resourceManager instanceof DefaultResourceManager )
assertTrue ( resourceManager instanceof DefaultResourceManager )
assertEquals ( "Selected Pool and expected pool is different" , testPool1 , selectedPool )
assertEquals ( "Selected Pool and expected pool is different" , testPool1 , selectedPool )
assertEquals ( "Selected Pool and expected pool is different" , testPool2 , selectedPool )
assertEquals ( expectedId , future . get ( ) )
assertEquals ( expectedB , future . get ( ) )
assertEquals ( returnedProfile , mockProfile )
assertEquals ( returnedProfile , mockProfile )
assertEquals ( response , mockResponse )
assertEquals ( response , mockResponse )
assertEquals ( failureCaught , true )
assertEquals ( slice_target , "10" )
assertEquals ( "2" , maxWidth )
assertEquals ( "BOOT" , scope )
assertEquals ( "SYSTEM" , scope )
assertNull ( config_server )
assertThat ( e . getMessage ( ) , containsString ( "User impersonation is not enabled" ) )
assertThat ( e . getMessage ( ) , containsString ( "not a valid value" ) )
assertThat ( responseHeaders . get ( "MyHeader" ) . get ( 0 ) , equalTo ( "102030" ) )
assertTrue ( e instanceof NullPointerException )
assertEquals ( "Counts should match" , 1 , cnt )
assertThat ( e . getMessage ( ) , containsString ( "ClassPathFileSystem doesn't currently support listing files" ) )
assertEquals ( "A" , queryBuilder ( ) . sql ( "values('A')" ) . singletonString ( ) )
assertEquals ( "Path should match" , firstCreatedParentPath , createdParentPath )
assertEquals ( "Path should match" , firstCreatedParentPath , createdParentPath )
assertEquals ( "Path should match" , file , createdFile )
assertEquals ( "Path should match" , firstCreatedParentPath , createdParentPath )
assertEquals ( "Path should match" , firstCreatedParentPath , createdParentPath )
assertNull ( plugins )
assertEquals ( SchemaBuilder . builder ( ) . stringType ( ) , actual )
assertTrue ( tupleMetadata . isEquivalent ( AvroSchemaUtil . convert ( schema ) ) )
assertTrue ( tupleMetadata . isEquivalent ( AvroSchemaUtil . convert ( schema ) ) )
assertNull ( selection )
assertNull ( results )
assertTrue ( e . getMessage ( ) . contains ( "does not allow null values" ) )
assertTrue ( e . getMessage ( ) . contains ( LONG_HINT ) )
assertTrue ( e . getMessage ( ) . contains ( LONG_HINT ) )
assertTrue ( e . getMessage ( ) . contains ( "Unexpected JSON value: VALUE_NUMBER_FLOAT" ) )
assertNull ( loader . next ( ) )
assertNull ( loader . next ( ) )
assertTrue ( e . getMessage ( ) . contains ( "JSON object expected" ) )
assertTrue ( e . getMessage ( ) . contains ( "JSON object expected" ) )
assertTrue ( e . getMessage ( ) . contains ( "Structure value found where scalar expected" ) )
assertTrue ( e . getMessage ( ) . contains ( "must define at least one header" ) )
assertTrue ( e . getMessage ( ) . contains ( "Error parsing JSON - Illegal unquoted character" ) )
assertEquals ( 25 , rowCount )
assertEquals ( expectedRowCount , actualRowCount )
assertEquals ( "Counts should match" , 2 , cnt )
assertTrue ( "no mapping for entry " + i , mappings . get ( i ) != null && mappings . get ( i ) . size ( ) > 0 )
assertNull ( pluginRegistry . getPlugin ( CP_PLUGIN_NAME ) )
assertTrue ( e . getMessage ( ) . startsWith ( "Illegal storage key name" ) )
assertThat ( ex . getMessage ( ) , containsString ( "RESOURCE ERROR: File listing size limit" ) )
assertEquals ( expectedValues [ i ] , map . get ( expectedValues [ i ] ) )
assertEquals ( "2012-11-05T13:00:30.120" , formattedValue )
assertEquals ( "2012-11-05" , formattedValue )
assertEquals ( "1:00:30 PM" , formattedValue )
assertNull ( formattedValue )
assertEquals ( UserBitShared . SerializedField . getDefaultInstance ( ) . getMajorType ( ) , genericAccessor . getType ( ) )
assertEquals ( expected , deserialized )
assertEquals ( "sys" , connection . getSchema ( ) )
assertTrue ( rs . next ( ) )
assertThat ( rowsMetadata . getColumnLabel ( 1 ) , equalTo ( "TABLE_CAT" ) )
assertThat ( rowsMetadata . getColumnName ( 2 ) , equalTo ( "TABLE_SCHEM" ) )
assertThat ( rowsMetadata . getColumnType ( 3 ) , equalTo ( Types . VARCHAR ) )
assertThat ( getIntOrNull ( mdrOptBOOLEAN , "DATA_TYPE" ) , equalTo ( Types . BOOLEAN ) )
assertThat ( getIntOrNull ( mdrOptVARBINARY_16 , "DATA_TYPE" ) , equalTo ( Types . VARBINARY ) )
assertThat ( getIntOrNull ( mdrReqTIME , "DATA_TYPE" ) , equalTo ( Types . TIME ) )
assertThat ( getIntOrNull ( mdrReqINTERVAL_Y , "DATA_TYPE" ) , equalTo ( Types . OTHER ) )
assertThat ( rowsMetadata . getColumnTypeName ( 5 ) , equalTo ( "INTEGER" ) )
assertThat ( mdrReqCHAR_5 . getString ( "TYPE_NAME" ) , equalTo ( "CHARACTER" ) )
assertThat ( mdrOptTIMESTAMP . getString ( "TYPE_NAME" ) , equalTo ( "TIMESTAMP" ) )
assertThat ( getIntOrNull ( mdrOptBOOLEAN , "COLUMN_SIZE" ) , equalTo ( 1 ) )
assertThat ( getIntOrNull ( mdrOptBIGINT , "COLUMN_SIZE" ) , equalTo ( 64 ) )
assertThat ( getIntOrNull ( mdrOptVARBINARY_16 , "COLUMN_SIZE" ) , equalTo ( 16 ) )
assertThat ( rowsMetadata . getColumnTypeName ( 7 ) , equalTo ( "INTEGER" ) )
assertThat ( rowsMetadata . getColumnLabel ( 9 ) , equalTo ( "DECIMAL_DIGITS" ) )
assertThat ( getIntOrNull ( mdrReqINTEGER , "DECIMAL_DIGITS" ) , equalTo ( 0 ) )
assertThat ( getIntOrNull ( mdrReqDOUBLE , "DECIMAL_DIGITS" ) , equalTo ( 15 ) )
assertThat ( getIntOrNull ( mdrOptVARCHAR , "DECIMAL_DIGITS" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptBINARY_65536 , "DECIMAL_DIGITS" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqTIME , "DECIMAL_DIGITS" ) , equalTo ( 3 ) )
assertThat ( getIntOrNull ( mdrReqINTERVAL_D , "DECIMAL_DIGITS" ) , equalTo ( 6 ) )
assertThat ( getIntOrNull ( mdrReqINTERVAL_4D_H , "DECIMAL_DIGITS" ) , equalTo ( 6 ) )
assertThat ( getIntOrNull ( mdrReqINTERVAL_1H_Mi , "DECIMAL_DIGITS" ) , equalTo ( 6 ) )
assertThat ( getIntOrNull ( mdrReqINTERVAL_3H_S1 , "DECIMAL_DIGITS" ) , equalTo ( 1 ) )
assertThat ( rowsMetadata . getColumnType ( 9 ) , equalTo ( Types . INTEGER ) )
assertThat ( rowsMetadata . getColumnLabel ( 10 ) , equalTo ( "NUM_PREC_RADIX" ) )
assertThat ( getIntOrNull ( mdrReqINTEGER , "NUM_PREC_RADIX" ) , equalTo ( 2 ) )
assertThat ( getIntOrNull ( mdrOptFLOAT , "NUM_PREC_RADIX" ) , equalTo ( 2 ) )
assertThat ( getIntOrNull ( mdrReqVARCHAR_10 , "NUM_PREC_RADIX" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptVARBINARY_16 , "NUM_PREC_RADIX" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqTIME , "NUM_PREC_RADIX" ) , equalTo ( 10 ) )
assertThat ( getIntOrNull ( mdrReqINTERVAL_Y , "NUM_PREC_RADIX" ) , equalTo ( 10 ) )
assertThat ( rowsMetadata . getColumnName ( 10 ) , equalTo ( "NUM_PREC_RADIX" ) )
assertThat ( rowsMetadata . getColumnType ( 12 ) , equalTo ( Types . VARCHAR ) )
assertThat ( rowsMetadata . getColumnName ( 15 ) , equalTo ( "SQL_DATETIME_SUB" ) )
assertThat ( getIntOrNull ( mdrReqDATE , "CHAR_OCTET_LENGTH" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptTIMESTAMP , "CHAR_OCTET_LENGTH" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptFLOAT , "ORDINAL_POSITION" ) , equalTo ( 7 ) )
assertThat ( getIntOrNull ( mdrReqDOUBLE , "ORDINAL_POSITION" ) , equalTo ( 8 ) )
assertThat ( rowsMetadata . getColumnName ( 17 ) , equalTo ( "ORDINAL_POSITION" ) )
assertThat ( rowsMetadata . getColumnTypeName ( 17 ) , equalTo ( "INTEGER" ) )
assertThat ( rowsMetadata . getColumnLabel ( 18 ) , equalTo ( "IS_NULLABLE" ) )
assertThat ( mdrOptFLOAT . getString ( "IS_NULLABLE" ) , equalTo ( "YES" ) )
assertThat ( mdrReqDECIMAL_5_3 . getString ( "IS_NULLABLE" ) , equalTo ( "NO" ) )
assertThat ( mdrReqCHAR_5 . getString ( "IS_NULLABLE" ) , equalTo ( "NO" ) )
assertThat ( mdrReqDATE . getString ( "IS_NULLABLE" ) , equalTo ( "NO" ) )
assertThat ( mdrOptTIMESTAMP . getString ( "IS_NULLABLE" ) , equalTo ( "YES" ) )
assertThat ( rowsMetadata . getColumnType ( 20 ) , equalTo ( Types . VARCHAR ) )
assertThat ( rowsMetadata . getColumnType ( 21 ) , equalTo ( Types . VARCHAR ) )
assertThat ( rowsMetadata . getColumnTypeName ( 22 ) , equalTo ( "SMALLINT" ) )
assertThat ( dbmd . getIdentifierQuoteString ( ) , equalTo ( Quoting . BACK_TICK . string ) )
assertThat ( dbmd . getProcedures ( null , null , "%" ) , notNullValue ( ) )
assertThat ( dbmd . getTableTypes ( ) , notNullValue ( ) )
assertThat ( dbmd . getFunctions ( null , "%" , "%" ) , notNullValue ( ) )
assertNull ( resultSet . getObject ( 1 ) )
assertThat ( connection , not ( nullValue ( ) ) )
assertThat ( rowsMetadata . getColumnTypeName ( 22 ) , equalTo ( "INTEGER" ) )
assertTrue ( rowCount > 0 )
assertEquals ( 0L , timeoutValue )
assertEquals ( 1 , rowCount )
assertThat ( testDataRow . getInt ( "C_INTEGER_3" ) , equalTo ( 3 ) )
assertThat ( testDataRow . getInt ( "C_DECIMAL_10.10" ) , equalTo ( 10 ) )
assertThat ( testDataRow . getLong ( "C_BIGINT_4" ) , equalTo ( 4L ) )
assertThat ( testDataRow . getFloat ( "C_INTEGER_3" ) , equalTo ( 3f ) )
assertThat ( testDataRow . getFloat ( "C_DECIMAL_10.10" ) , equalTo ( 10.10f ) )
assertThat ( testDataRow . getDouble ( "C_INTEGER_3" ) , equalTo ( 3D ) )
assertThat ( testDataRow . getBigDecimal ( "C_DECIMAL_10.5" ) , equalTo ( new BigDecimal ( "10.5" ) ) )
assertThat ( rowMetadata . getPrecision ( ordOptBOOLEAN ) , equalTo ( 0 ) )
assertTrue ( rowCount > 0 )
assertEquals ( 0 , timeoutValue )
assertEquals ( 3 , rowCount )
assertThat ( uut . getInt ( 0 ) , equalTo ( 2147483647 ) )
assertThat ( uut . getLong ( 0 ) , equalTo ( 9223372036854775807L ) )
assertThat ( uut . getLong ( 0 ) , equalTo ( 9223372036854775807L ) )
assertNotNull ( connection )
assertNotNull ( connection )
fail ( "org.apache.drill.jdbc.Driver not found using ServiceLoader" )
assertThat ( rowsMetadata . getColumnLabel ( 1 ) , equalTo ( "TABLE_CATALOG" ) )
assertThat ( rowsMetadata . getColumnLabel ( 5 ) , equalTo ( "ORDINAL_POSITION" ) )
assertThat ( rowsMetadata . getColumnName ( 5 ) , equalTo ( "ORDINAL_POSITION" ) )
assertThat ( mdrOptBOOLEAN . getString ( "COLUMN_DEFAULT" ) , nullValue ( ) )
assertThat ( rowsMetadata . getColumnName ( 6 ) , equalTo ( "COLUMN_DEFAULT" ) )
assertThat ( rowsMetadata . getColumnLabel ( 7 ) , equalTo ( "IS_NULLABLE" ) )
assertThat ( rowsMetadata . getColumnType ( 7 ) , equalTo ( Types . VARCHAR ) )
assertThat ( mdrOptFLOAT . getString ( "DATA_TYPE" ) , equalTo ( "FLOAT" ) )
assertThat ( mdrReqVARCHAR_10 . getString ( "DATA_TYPE" ) , equalTo ( "CHARACTER VARYING" ) )
assertThat ( mdrOptVARBINARY_16 . getString ( "DATA_TYPE" ) , equalTo ( "BINARY VARYING" ) )
assertThat ( getIntOrNull ( mdrReqDECIMAL_5_3 , "CHARACTER_MAXIMUM_LENGTH" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqCHAR_5 , "CHARACTER_MAXIMUM_LENGTH" ) , equalTo ( 5 ) )
assertThat ( getIntOrNull ( mdrReqDATE , "CHARACTER_MAXIMUM_LENGTH" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptTIMESTAMP , "CHARACTER_MAXIMUM_LENGTH" ) , nullValue ( ) )
assertThat ( rowsMetadata . getColumnTypeName ( 9 ) , equalTo ( "INTEGER" ) )
assertThat ( getIntOrNull ( mdrReqINTEGER , "CHARACTER_OCTET_LENGTH" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptTIME_7 , "CHARACTER_OCTET_LENGTH" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqINTERVAL_3H_S1 , "CHARACTER_OCTET_LENGTH" ) , nullValue ( ) )
assertThat ( rowsMetadata . getColumnName ( 10 ) , equalTo ( "CHARACTER_OCTET_LENGTH" ) )
assertThat ( getIntOrNull ( mdrOptFLOAT , "NUMERIC_PRECISION" ) , equalTo ( 24 ) )
assertThat ( getIntOrNull ( mdrReqVARCHAR_10 , "NUMERIC_PRECISION" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptVARBINARY_16 , "NUMERIC_PRECISION" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqTIME , "NUMERIC_PRECISION" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqINTERVAL_Y , "NUMERIC_PRECISION" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptBIGINT , "NUMERIC_PRECISION_RADIX" ) , equalTo ( 2 ) )
assertThat ( getIntOrNull ( mdrReqDECIMAL_5_3 , "NUMERIC_PRECISION_RADIX" ) , equalTo ( 10 ) )
assertThat ( getIntOrNull ( mdrReqCHAR_5 , "NUMERIC_PRECISION_RADIX" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqDATE , "NUMERIC_PRECISION_RADIX" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptTIMESTAMP , "NUMERIC_PRECISION_RADIX" ) , nullValue ( ) )
assertThat ( rowsMetadata . getColumnTypeName ( 12 ) , equalTo ( "INTEGER" ) )
assertThat ( getIntOrNull ( mdrReqINTEGER , "NUMERIC_SCALE" ) , equalTo ( 0 ) )
assertThat ( getIntOrNull ( mdrReqDOUBLE , "NUMERIC_SCALE" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptVARCHAR , "NUMERIC_SCALE" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptBINARY_65536 , "NUMERIC_SCALE" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptTIME_7 , "NUMERIC_SCALE" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqINTERVAL_3H_S1 , "NUMERIC_SCALE" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqVARCHAR_10 , "DATETIME_PRECISION" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptVARBINARY_16 , "DATETIME_PRECISION" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqINTERVAL_D , "DATETIME_PRECISION" ) , equalTo ( 6 ) )
assertThat ( getIntOrNull ( mdrReqINTERVAL_2D_S5 , "DATETIME_PRECISION" ) , equalTo ( 5 ) )
assertThat ( mdrReqDOUBLE . getString ( "INTERVAL_TYPE" ) , nullValue ( ) )
assertThat ( mdrOptVARCHAR . getString ( "INTERVAL_TYPE" ) , nullValue ( ) )
assertThat ( mdrOptBINARY_65536 . getString ( "INTERVAL_TYPE" ) , nullValue ( ) )
assertThat ( mdrOptTIME_7 . getString ( "INTERVAL_TYPE" ) , nullValue ( ) )
assertThat ( mdrReqINTERVAL_3Y_Mo . getString ( "INTERVAL_TYPE" ) , equalTo ( "YEAR TO MONTH" ) )
assertThat ( mdrReqINTERVAL_4D_H . getString ( "INTERVAL_TYPE" ) , equalTo ( "DAY TO HOUR" ) )
assertThat ( mdrReqINTERVAL_H . getString ( "INTERVAL_TYPE" ) , equalTo ( "HOUR" ) )
assertThat ( mdrReqINTERVAL_Mi . getString ( "INTERVAL_TYPE" ) , equalTo ( "MINUTE" ) )
assertThat ( mdrReqINTERVAL_3S . getString ( "INTERVAL_TYPE" ) , equalTo ( "SECOND" ) )
assertThat ( getIntOrNull ( mdrOptFLOAT , "INTERVAL_PRECISION" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqVARCHAR_10 , "INTERVAL_PRECISION" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrOptVARBINARY_16 , "INTERVAL_PRECISION" ) , nullValue ( ) )
assertThat ( getIntOrNull ( mdrReqTIME , "INTERVAL_PRECISION" ) , nullValue ( ) )
assertNotNull ( "allocation failed" , drillBuf )
assertEquals ( expected , schema . jsonString ( ) )
assertEquals ( "`Id` INT NOT NULL" , SchemaExprParser . parseSchema ( schema ) . metadata ( 0 ) . columnString ( ) )
assertEquals ( expected , TableKey . of ( unit ) )
assertEquals ( expected , tableKey . toLocation ( "/metastore" ) )
assertEquals ( expected . toString ( ) , operation . filter ( ) . toString ( ) )
assertEquals ( expectedResult , actualResult )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , transformer . transform ( conditions ) . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertEquals ( expected . toString ( ) , actual . toString ( ) )
assertNull ( tableMetadata )
assertTrue ( requestMetadata . columns ( ) . isEmpty ( ) )
assertThat ( e . getMessage ( ) , startsWith ( "Unsupported metadata types are detected" ) )
assertEquals ( expected . toString ( ) , operation . filter ( ) . toString ( ) )
assertEquals ( expectedResult , actualResult )
assertThat ( e . getMessage ( ) , startsWith ( "Metadata mapper is absent for type" ) )
assertThat ( e . getMessage ( ) , startsWith ( "Metadata mapper is absent for type" ) )
