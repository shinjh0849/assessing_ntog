assertEquals ( expected , actual )
assertEquals ( expected , actual . getType ( ) )
assertEquals ( expected , actual )
assertEquals ( expected , actual )
assertEquals ( expected , actual )
assertEquals ( allergies . getAllergyStatus ( ) , Allergies . NO_KNOWN_ALLERGIES )
assertEquals ( ns + FORM_NAMESPACE_PATH_SEPARATOR + path , formNamespaceAndPathProperty . get ( impl ) )
assertEquals ( ns , impl . getFormFieldNamespace ( ) )
assertNull ( impl . getFormFieldPath ( ) )
assertEquals ( path , impl . getFormFieldPath ( ) )
assertFalse ( ( session . load ( Patient . class , 2 ) ) . equals ( ( session . load ( Concept . class , 11 ) ) ) )
assertFalse ( newMember . isActive ( dateToTest ) )
assertFalse ( newMember . isActive ( dateToTest ) )
Arrays . stream ( ids ) . forEach ( id -> assertTrue ( cohort . contains ( id ) ) )
assertTrue ( secondsToSet < 5 , "Setting cohort of size " + cohortSize + " took " + secondsToSet + " seconds" )
assertEquals ( frenchConceptName , concept . getName ( Locale . FRENCH ) )
assertEquals ( frenchConceptName , concept . getName ( Locale . FRENCH ) )
assertTrue ( term . equals ( term . getConceptReferenceTermMaps ( ) . iterator ( ) . next ( ) . getTermA ( ) ) )
assertFalse ( compatibleNames . contains ( name_en_UK ) )
assertEquals ( expectedAutoExpireDate , drugOrder . getAutoExpireDate ( ) )
assertEquals ( expectedAutoExpireDate , drugOrder . getAutoExpireDate ( ) )
assertEquals ( drug1 , drug1 . getDrugReferenceMaps ( ) . iterator ( ) . next ( ) . getDrug ( ) )
assertEquals ( createDateTime ( "2014-07-01 10:00:30" ) , autoExpireDate )
assertEquals ( createDateTime ( "2014-07-01 20:00:00" ) , autoExpireDate )
assertEquals ( createDateTime ( "2014-07-31 10:00:00" ) , autoExpireDate )
assertEquals ( createDateTime ( "2017-07-01 10:00:00" ) , autoExpireDate )
assertEquals ( createDateTime ( "2014-07-22 10:00:00" ) , duration . addToDate ( startDate , onceAWeek ) )
assertThat ( exception . getMessage ( ) , is ( Context . getMessageSourceService ( ) . getMessage ( "Duration.error.frequency.null" ) ) )
assertEquals ( daysCode , Duration . getCode ( concept ) )
assertEquals ( 0 , enc . getObs ( ) . size ( ) )
assertTrue ( obs . getEncounter ( ) . equals ( encounter ) )
assertTrue ( order . getEncounter ( ) . equals ( encounter ) )
assertTrue ( encounter . hasDiagnosis ( diagnosis ) )
assertFalse ( encounter . hasDiagnosis ( diagnosis ) )
assertEquals ( 123 , encounterType . getEncounterTypeId ( ) . intValue ( ) )
assertEquals ( 123 , form . getFormId ( ) . intValue ( ) )
assertFalse ( obsService . getObs ( 7 ) . isDirty ( ) )
assertFalse ( obs . getValueAsBoolean ( ) )
assertTrue ( passes , currentClass . getName ( ) + "#" + methodName + " is supposed to either 1) start with 'should' or 2) contain '_should' but it doesn't" )
assertFalse ( foundATestMethod , currentClass . getName ( ) + " does not end with 'Test' but contains @Test annotated methods" )
assertNotNull ( previousOrder )
assertNotNull ( orderGroup . getPreviousOrderGroup ( ) )
assertNull ( orderGroup . getPreviousOrderGroup ( ) )
assertTrue ( order . isActive ( dateStopped ) )
assertTrue ( ot . getConceptClasses ( ) . contains ( cc ) )
assertFalse ( active )
assertTrue ( result > 0 )
assertTrue ( result < 0 )
assertTrue ( result <= - 1 || result >= 1 )
assertTrue ( p . getActiveIdentifiers ( ) . contains ( pa2 ) , "The second identifier has not been added as a new identifier" )
assertTrue ( pa . getVoided ( ) )
assertEquals ( "family name" , new PersonName ( ) . getFamilyName ( ) )
assertNull ( pn . getFamilyName2 ( ) )
assertNull ( pn . getFamilyNamePrefix ( ) )
assertNull ( pn . getFamilyNameSuffix ( ) )
assertEquals ( "given name" , new PersonName ( ) . getGivenName ( ) )
assertEquals ( "middle name" , new PersonName ( ) . getMiddleName ( ) )
assertEquals ( "Bob Jones" , pn . getFullName ( ) )
assertEquals ( pn . getFullName ( ) , "Sr. Taylor Bob Mark" )
assertEquals ( pn . getFullName ( ) , "Sr. Taylor Bob Wilson Mark Jones jr. 3" )
assertEquals ( pn . getFullName ( ) , "Sr. Taylor Bob Mark" )
assertEquals ( person . getAge ( onDate . getTime ( ) ) , 2 , 0 )
assertEquals ( person . getAge ( onDate . getTime ( ) ) , 1 , 0 )
assertEquals ( person . getAge ( onDate . getTime ( ) ) , 2 , 0 )
assertEquals ( 10 , person . getAge ( ) , 0 )
assertEquals ( 5 , person . getAge ( givenDate . getTime ( ) ) , 0 )
assertTrue ( actualPersonAddress . getVoided ( ) )
assertNull ( notVoidedPerson . getPersonAddress ( ) )
assertNull ( notVoidedPerson . getPersonName ( ) )
assertEquals ( new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) . parse ( "2012-01-01 11:11:11" ) , person . getBirthDateTime ( ) )
assertEquals ( "name3" , person . getAttribute ( "name3" ) . getAttributeType ( ) . getName ( ) )
assertNull ( person . getAttribute ( 3 ) )
assertEquals ( person . getPersonName ( ) . getFullName ( ) , provider . getName ( ) )
assertEquals ( createDateTime ( "2014-07-01 10:00:29" ) , autoExpireDate )
assertEquals ( createDateTime ( "2014-07-30 23:59:59" ) , drugOrder . getAutoExpireDate ( ) )
assertEquals ( null , autoExpireDate )
assertEquals ( null , autoExpireDate )
assertTrue ( fetchedLocations . contains ( location ) )
assertNull ( afterNull , "There shouldn't be an impl id defined after setting a null impl id" )
assertNull ( afterInvalid , "There shouldn't be an impl id defined after setting an invalid impl id" )
assertNull ( afterInvalid2 , "There shouldn't be an impl id defined after setting an invalid impl id" )
assertEquals ( validId , adminService . getImplementationId ( ) )
assertNotNull ( gp . getUuid ( ) )
assertEquals ( "correct-value" , propertyValue )
assertNull ( adminService . getGlobalPropertyByUuid ( "some invalid uuid" ) )
assertNotNull ( adminService . getGlobalPropertyObject ( "new prop" ) . getUuid ( ) )
assertNull ( adminService . getGlobalPropertyObject ( "magicResistSkill" ) )
assertNull ( adminService . getImplementationId ( ) )
assertNotNull ( adminService . getGlobalProperty ( "detectHiddenSkill" ) )
assertThat ( exception . getMessage ( ) , containsString ( "is not in allowed locales list" ) )
assertTrue ( service . getCohort ( 2 ) . getDescription ( ) . equals ( modifiedCohortDescription ) )
assertEquals ( 2 , cohortToGet . getCohortId ( ) )
assertFalse ( membersAsOfDate . stream ( ) . anyMatch ( m -> m . getStartDate ( ) . equals ( dateToTest ) ) )
assertFalse ( concept . getConceptId ( ) . equals ( 5089 ) )
assertNull ( concept )
assertTrue ( drugs . contains ( drug ) )
assertEquals ( 10 , Context . getConceptService ( ) . getConceptReferenceTerms ( false ) . size ( ) )
assertNull ( drug )
assertFalse ( voided )
assertTrue ( sourceEncounterAfterTransfer . getVoided ( ) )
assertTrue ( visit . getVoided ( ) )
assertNotNull ( ff )
assertNotNull ( formService . getFieldType ( fieldType . getFieldTypeId ( ) ) )
assertNull ( Context . getFormService ( ) . getFormField ( new Form ( 1 ) , new Concept ( 293934 ) , null , false ) )
assertNull ( Context . getFormService ( ) . getFormField ( new Form ( 12343 ) , new Concept ( 293934 ) , null , false ) )
assertNull ( Context . getFormService ( ) . getFieldAnswerByUuid ( "some invalid uuid" ) )
assertEquals ( 2 , ( int ) fieldType . getFieldTypeId ( ) )
assertNull ( Context . getFormService ( ) . getFieldTypeByUuid ( "some invalid uuid" ) )
assertNull ( Context . getFormService ( ) . getFormByUuid ( "some invalid uuid" ) )
assertNull ( Context . getFormService ( ) . getFormFieldByUuid ( "some invalid uuid" ) )
assertNotNull ( field . getUuid ( ) )
assertEquals ( 1 , Context . getFormService ( ) . getFormsContainingConcept ( concept ) . size ( ) )
assertNull ( fs . getForm ( 1 ) )
assertEquals ( form , duplicateForm )
assertEquals ( 0 , Context . getLocationService ( ) . getLocations ( "Mansion" ) . size ( ) )
assertFalse ( tag . getRetired ( ) )
assertNotNull ( dispense . getId ( ) )
assertTrue ( obs . getVoided ( ) )
assertTrue ( oSaved . getObsId ( ) . equals ( o . getObsId ( ) ) )
assertFalse ( obsSaved . getObsId ( ) . equals ( obs . getObsId ( ) ) )
assertFalse ( obs . getVoided ( ) )
assertTrue ( obs . getVoided ( ) )
assertThat ( exception . getMessage ( ) , containsString ( "failed to validate with reason:" ) )
assertThat ( exception . getMessage ( ) , is ( "patient and concept are required" ) )
assertThat ( exception . getMessage ( ) , is ( "patient and concept are required" ) )
assertEquals ( "28090760-7c38-11e3-baa7-0800200c9a66" , orderService . getOrderFrequency ( 1 ) . getUuid ( ) )
assertThat ( exception . getMessage ( ) , is ( "Discontinue date cannot be in the future" ) )
assertThat ( exception . getMessage ( ) , is ( "Discontinue date cannot be in the future" ) )
assertThat ( exception . getMessage ( ) , is ( "Order.cannot.edit.existing" ) )
assertEquals ( 1 , cs . getId ( ) . intValue ( ) )
assertThat ( exception . getMessage ( ) , is ( "searchPhrase is required" ) )
assertTrue ( order . getOrderNumber ( ) . startsWith ( TimestampOrderNumberGenerator . ORDER_NUMBER_PREFIX ) )
assertEquals ( dateformat . parse ( "18/08/2014 23:59:59.000" ) , order . getAutoExpireDate ( ) )
assertEquals ( "Drug order" , orderService . getOrderType ( 1 ) . getName ( ) )
assertNull ( orderType )
assertEquals ( "Drug order" , orderType . getName ( ) )
assertNull ( orderService . getOrderTypeByUuid ( "some random uuid" ) )
assertEquals ( "131168f4-15f5-102d-96e4-000c29c2a5d7" , orderType . getUuid ( ) )
assertThat ( exception . getMessage ( ) , is ( "Patient is required" ) )
assertThat ( exception . getMessage ( ) , is ( "CareSetting is required" ) )
assertEquals ( 2 , order . getOrderType ( ) . getOrderTypeId ( ) . intValue ( ) )
assertThat ( exception . getMessage ( ) , is ( "Order.type.cannot.determine" ) )
assertEquals ( orderService . getOrder ( 111 ) , orderService . getRevisionOrder ( orderService . getOrder ( 1 ) ) )
assertNull ( orderService . getRevisionOrder ( orderService . getOrder ( 444 ) ) )
assertThat ( orderService . getDurationUnits ( ) , is ( empty ( ) ) )
assertThat ( exception . getMessage ( ) , is ( "The orderable of the previous order and the new one order don't match" ) )
assertThat ( exception . getMessage ( ) , is ( messageSourceService . getMessage ( "Order.cannot.discontinue.inactive" ) ) )
assertEquals ( "9cf1bce0-d18e-11ea-87d0-0242ac130003" , orderGroupAttributeType . getUuid ( ) )
assertNull ( orderService . getOrderGroupAttributeTypeByUuid ( "cbf580ee-d7fb-11ea-87d0-0242ac130003" ) )
assertEquals ( NAMESPACE + "^" + FORMFIELD_PATH , order . getFormNamespaceAndPath ( ) )
assertNull ( orderService . getOrderAttributeTypeById ( 15 ) )
assertThat ( orderService . getOrderAttributeTypeById ( 2 ) . getId ( ) , is ( 2 ) )
assertNull ( orderService . getOrderAttributeByUuid ( "26bbdf73-4268-4e65-aa72-54cb928870d6" ) )
assertEquals ( new Integer ( 4 ) , numberOfOrderSetMembers )
assertNotNull ( orderSetMember . getId ( ) )
assertEquals ( "2011-04-25" , service . getOrderSetAttributeByUuid ( "3a4bdb18-6faa-22e0-8414-001e376eb68e" ) . getValueReference ( ) )
assertNull ( service . getOrderSetAttributeByUuid ( "not-a-uuid" ) )
assertEquals ( initialOrderSetAttributeTypesCount - 1 , Context . getOrderSetService ( ) . getAllOrderSetAttributeTypes ( ) . size ( ) )
assertFalse ( allergy . getAllergen ( ) . isCoded ( ) )
assertTrue ( Context . getPersonService ( ) . getPerson ( 2 ) . getVoided ( ) )
assertNull ( patient )
assertNull ( patient )
assertNull ( identifierType )
assertNull ( identifierType )
assertNull ( identifierType )
assertNull ( identifierType )
assertNull ( voidedPatient )
assertNull ( person )
assertNull ( deletedRelationship )
assertNull ( personName )
assertFalse ( person . getVoided ( ) )
assertTrue ( person . getVoided ( ) )
assertNull ( p )
assertNull ( pws . getProgramByName ( "A name" ) )
assertThat ( exception . getMessage ( ) , is ( "Program concept is required" ) )
assertThat ( exception . getMessage ( ) , is ( "ProgramWorkflow concept is required" ) )
assertThat ( exception . getMessage ( ) , is ( "ProgramWorkflowState concept, initial, terminal are required" ) )
assertThat ( exception . getMessage ( ) , is ( "ProgramWorkflowState concept, initial, terminal are required" ) )
assertThat ( exception . getMessage ( ) , is ( "ProgramWorkflowState concept, initial, terminal are required" ) )
assertThat ( exception . getMessage ( ) , is ( "PatientProgram requires a Patient and a Program" ) )
assertThat ( exception . getMessage ( ) , is ( "Cascade purging of PatientPrograms is not implemented yet" ) )
assertTrue ( providers . contains ( provider ) )
assertThat ( exception . getMessage ( ) , is ( "This method can be used for only creating new users" ) )
assertNotNull ( u , "There needs to be a user with username 'admin' in the database" )
assertNotNull ( user , "username not found " + ADMIN_USERNAME )
assertEquals ( "Some Privilege" , privilege . getPrivilege ( ) )
assertEquals ( "Provider" , role . getRole ( ) )
assertNull ( userService . getUserByUuid ( "some invalid uuid" ) )
assertEquals ( user , userService . getUser ( 5505 ) , "Did not fetch user with given uuid" )
assertEquals ( "Some Privilege" , privilege . getPrivilege ( ) )
assertEquals ( "Some Role" , role . getRole ( ) )
assertNull ( userService . getPrivilege ( "Some Privilege" ) )
assertNull ( userService . getRole ( "Some Role To Delete" ) )
assertNotNull ( savedPrivilege )
assertNotNull ( userService . getRole ( "new role" ) )
assertThat ( exception . getMessage ( ) , is ( messages . getMessage ( "Role.cannot.inherit.descendant" ) ) )
assertThat ( exception . getMessage ( ) , is ( "You must have the following privileges in order to assign them: another privilege" ) )
assertThat ( exception . getMessage ( ) , is ( messages . getMessage ( "error.privilegesRequired" , new Object [ ] { PrivilegeConstants . EDIT_USER_PASSWORDS } , null ) ) )
assertThat ( exception . getMessage ( ) , is ( messages . getMessage ( "error.privilegesRequired" , new Object [ ] { PrivilegeConstants . EDIT_USER_PASSWORDS } , null ) ) )
assertThat ( exception . getMessage ( ) , is ( messages . getMessage ( "error.password.length" , new Object [ ] { "8" } , null ) ) )
assertNotNull ( user , "User with email hank.williams@gmail not found in database" )
assertThat ( exception . getMessage ( ) , is ( messages . getMessage ( "error.usernameOrEmail.notNullOrBlank" ) ) )
assertThat ( exception . getMessage ( ) , is ( messages . getMessage ( "error.usernameOrEmail.notNullOrBlank" ) ) )
assertEquals ( createdUser , userService . getUserByActivationKey ( key ) )
assertNull ( userService . getUserByActivationKey ( key ) )
assertThat ( exception . getMessage ( ) , is ( messages . getMessage ( "activation.key.not.correct" ) ) )
assertNull ( visitService . getVisitType ( 4 ) )
assertNotNull ( visit . getId ( ) )
assertNull ( visitService . getVisitAttributeByUuid ( "not-a-uuid" ) )
assertTrue ( registeredComponent instanceof ExistingOrNewVisitAssignmentHandler )
assertTrue ( e . getMessage ( ) . startsWith ( Context . getMessageSourceService ( ) . getMessage ( "Scheduler.timer.task.only" , new Object [ ] { this . getClass ( ) . getName ( ) } , null ) ) )
assertThat ( exception . getMessage ( ) , is ( Context . getMessageSourceService ( ) . getMessage ( "Context.DAO.only" , new Object [ ] { this . getClass ( ) . getName ( ) } , null ) ) )
assertThat ( exception . getMessage ( ) , is ( Context . getMessageSourceService ( ) . getMessage ( "User.creating.already.exists" , new Object [ ] { u . getDisplayString ( ) } , null ) ) )
assertTrue ( true )
assertTrue ( dao . isConceptMapTypeInUse ( Context . getConceptService ( ) . getConceptMapType ( 6 ) ) )
assertEquals ( "admin" , u . getUsername ( ) , "Should be the admin user" )
assertEquals ( "1-8" , u . getSystemId ( ) , "Should be the 1-8 user" )
assertEquals ( 0 , patientCount )
assertEquals ( 0 , patientCount )
assertEquals ( 0 , patientCount )
assertEquals ( 0 , patientCount )
assertEquals ( 1 , patientCount )
assertEquals ( 11 , patientCount )
assertEquals ( 0 , patientCount )
assertEquals ( 0 , patientCount )
assertEquals ( 0 , patientCount )
assertEquals ( 1 , patientCount )
assertNull ( personName )
assertFalse ( searchable )
assertEquals ( 3 , savedProgram . getOutcomesConcept ( ) . getId ( ) . intValue ( ) )
assertNotNull ( u2 , "User should have been returned" )
assertEquals ( 105 , dao . getNextVisit ( dao . getVisit ( 1 ) , visitTypes , cal . getTime ( ) ) . getVisitId ( ) . intValue ( ) )
assertNotSame ( beforeDate , afterDate )
assertNotSame ( dateChangedBefore , weight . getDateChanged ( ) )
assertNotNull ( u . getDateCreated ( ) )
assertThat ( person . getBirthdate ( ) , is ( dateWithoutMillisecond ) )
assertThat ( person . getBirthdate ( ) , is ( dateWithoutMillisecond ) )
assertFalse ( errors . hasFieldErrors ( "role" ) )
assertEquals ( 1 , ( int ) diagnosis . getId ( ) )
assertNotNull ( dispense . getId ( ) )
assertEquals ( "Bacteriology" , orderGroupAttributeType . getName ( ) )
assertEquals ( "ECG" , orderGroupAttributeType . getName ( ) )
assertThat ( duplicatePatients . size ( ) , equalTo ( 0 ) )
assertFalse ( p . getVoided ( ) )
assertTrue ( providers . get ( 1 ) . getRetired ( ) )
assertThat ( exception . getMessage ( ) , is ( Context . getMessageSourceService ( ) . getMessage ( "editing.fields.not.allowed" , new Object [ ] { "[immutable]" , Order . class . getSimpleName ( ) } , null ) ) )
assertTrue ( patientSearchCriteria . isShortName ( "J" ) )
assertTrue ( providers . get ( 1 ) . getRetired ( ) )
assertTrue ( retireable . getRetired ( ) )
assertEquals ( 2 , retireable . getRetiredBy ( ) . getId ( ) . intValue ( ) )
assertFalse ( retireable . getRetired ( ) )
assertTrue ( retireable . getRetired ( ) )
assertFalse ( voidable . getVoided ( ) )
assertTrue ( voidable . getVoided ( ) )
assertTrue ( voidable . getVoided ( ) )
assertEquals ( 2 , voidable . getVoidedBy ( ) . getId ( ) . intValue ( ) )
assertNull ( newTag . getConceptNameTagId ( ) )
assertEquals ( NAME , loc . getName ( ) )
assertNotNull ( obj . getName ( ) )
assertNotNull ( obj . getDescription ( ) )
assertEquals ( "name" , obj . getName ( ) )
assertFalse ( person . getPersonVoided ( ) )
assertTrue ( person . getPersonVoided ( ) )
assertTrue ( person . getPersonVoided ( ) )
assertEquals ( 2 , person . getPersonVoidedBy ( ) . getId ( ) . intValue ( ) )
assertTrue ( drugs . contains ( conceptService . getDrug ( drugName ) ) )
assertTrue ( drug . getRetired ( ) )
assertFalse ( drug . getRetired ( ) )
assertEquals ( Integer . valueOf ( 2039 ) , savedCondition . getEncounter ( ) . getId ( ) )
assertEquals ( ns + FORM_NAMESPACE_PATH_SEPARATOR + path , savedCondition . getFormNamespaceAndPath ( ) )
assertEquals ( uuid , condition . getUuid ( ) )
assertNull ( conditionService . getConditionByUuid ( "invalid uuid" ) )
assertEquals ( uuid , diagnosis . getUuid ( ) )
assertNull ( diagnosisService . getDiagnosisAttributeTypeById ( 2021 ) )
assertNull ( diagnosisService . getDiagnosisAttributeTypeByUuid ( "077e8b7a-caa7-4882-bd99-8296829a661c" ) )
assertThat ( globalLocaleList . getAllowedLocales ( ) , contains ( Locale . ROOT ) )
assertEquals ( expectedUuid , datatype . serialize ( location ) )
assertEquals ( date , datatype . deserialize ( datatype . serialize ( date ) ) )
assertNotNull ( hl7 . getUuid ( ) )
assertEquals ( "+1100" , HL7Util . getTimeZoneOffset ( "348934934934+1100" , new Date ( ) ) )
assertEquals ( 5089 , new ORUR01Handler ( ) . getConcept ( "5089" , "99DCT" , "xj39bnj4k34nmf" ) . getId ( ) . intValue ( ) )
assertEquals ( 5089 , new ORUR01Handler ( ) . getConcept ( "WGT234" , "SSTRM" , "23498343sdnm3" ) . getId ( ) . intValue ( ) )
assertEquals ( "Text" , Context . getConceptService ( ) . getConcept ( 19 ) . getDatatype ( ) . getName ( ) )
assertEquals ( expected , actual )
assertEquals ( expected , actual )
assertTrue ( actual )
assertFalse ( actual )
assertFalse ( actual )
assertEquals ( expected , actual )
assertEquals ( expected , actual )
assertEquals ( 123 , ( ( Encounter ) firstResult . toObject ( ) ) . getId ( ) . intValue ( ) )
assertEquals ( "some value" , parentResult . earliest ( ) . toString ( ) )
assertEquals ( "some value" , parentResult . earliest ( ) . toString ( ) )
assertEquals ( new EmptyResult ( ) , parentResult . earliest ( ) )
assertEquals ( "some value" , parentResult . earliest ( ) . toString ( ) )
assertEquals ( "some value" , parentResult . latest ( ) . toString ( ) )
assertEquals ( "some other value" , result . latest ( ) . toString ( ) )
assertEquals ( new EmptyResult ( ) , new Result ( ) . latest ( ) )
assertEquals ( valueAsString , valueAsPM . getMessage ( ) )
assertThat ( module . getExtensions ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getExtensions ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertTrue ( ModuleFactory . getLoadedModules ( ) . contains ( test2 ) )
assertThat ( exception . getMessage ( ) , is ( "messageSourceService must not be null" ) )
assertThat ( module . getAwareOfModules ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getAwareOfModules ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getExtensions ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getExtensions ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getExtensions ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getPrivileges ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getPrivileges ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getGlobalProperties ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getGlobalProperties ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getGlobalProperties ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getMappingFiles ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( exception . getMessage ( ) , startsWith ( "Found the invalidTag node under conditionalResources." ) )
assertThat ( exception . getMessage ( ) , startsWith ( "The path of a conditional resource must not be blank" ) )
assertThat ( module . getAdvicePoints ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertThat ( module . getAdvicePoints ( ) , is ( equalTo ( Collections . EMPTY_LIST ) ) )
assertEquals ( "1.0" , testModule . getRequiredModuleVersion ( "mod1" ) )
assertTrue ( updateRdf . contains ( "<updates" ) , "Unable to fetch module update url: " + url )
assertTrue ( updateRdf . contains ( "<updates" ) , "Unable to fetch module update url: " + url )
assertEquals ( "/css/ui.css" , ModuleUtil . getPathForResource ( module , path ) )
assertNull ( ModuleUtil . getModuleForPath ( path ) )
assertNull ( nullURL )
assertEquals ( Alert . TEXT_MAX_LENGTH , lastAlert . getText ( ) . length ( ) )
assertEquals ( expectedText , lastAlert . getText ( ) )
assertEquals ( testMessage . getRecipients ( ) , recipients )
Assertions . assertNotNull ( hibernateAlertDAO . getAlert ( 5 ) )
Assertions . assertEquals ( ( int ) savedAlert . getAlertId ( ) , 2 )
assertNull ( editor . getValue ( ) )
assertNull ( editor . getValue ( ) )
assertThat ( editor . getValue ( ) , is ( getExistingObject ( ) ) )
assertThat ( editor . getValue ( ) , is ( getExistingObject ( ) ) )
assertThat ( editor . getAsText ( ) , is ( "" ) )
assertEquals ( "27/10/2011" , ed . getAsText ( ) )
assertEquals ( "27/10/2011 17:59" , ed . getAsText ( ) )
assertEquals ( ymdhm . parse ( "2011-10-27 17:59" ) , ed . getValue ( ) )
assertNotNull ( editor . getValue ( ) )
assertNotNull ( editor . getValue ( ) )
assertNotNull ( editor . getValue ( ) )
assertNotNull ( editor . getValue ( ) )
assertNotNull ( editor . getValue ( ) )
assertNotNull ( editor . getValue ( ) )
assertTrue ( true , "Class " + className + " is a valid Task" )
assertTrue ( latch . await ( CONCURRENT_TASK_WAIT_MS , TimeUnit . MILLISECONDS ) && consecutiveInitResult . get ( ) , "Init and execute methods should run consecutively" )
assertNotNull ( td )
assertNull ( td )
assertNotNull ( clientTask , "The clientTask variable is null, so either the TimerSchedulerServiceImpl.scheduleTask method hasn't finished or didn't get run" )
assertThat ( description . toString ( ) , is ( "to have field errors" ) )
assertThat ( description . toString ( ) , is ( "to have field errors for 'uuid' and code 'error.null'" ) )
assertThat ( description . toString ( ) , is ( "to have global errors" ) )
assertTrue ( r1 . contains ( d ) )
assertEquals ( actualValue , - 1 )
assertEquals ( actualValue , 0 )
assertEquals ( actualValue , 1 )
assertEquals ( "" , Format . format ( null , null , null ) )
assertEquals ( "" , Format . format ( null , null , Format . FORMAT_TYPE . DATE ) )
assertEquals ( "" , Format . format ( new Date ( 1460323142 ) , null , Format . FORMAT_TYPE . DATE ) )
assertEquals ( "" , Format . format ( new Date ( 1460323539000L ) , Locale . US , null ) )
assertThat ( exception . getMessage ( ) , is ( Context . getMessageSourceService ( ) . getMessage ( "handler.type.not.found" , new Object [ ] { Validator . class . toString ( ) , Integer . class } , null ) ) )
assertThat ( exception . getMessage ( ) , is ( "Not a valid http(s) url" ) )
assertThat ( new HttpUrl ( "http://something" ) . toString ( ) , is ( "http://something" ) )
assertTrue ( localesInOrder . contains ( ENGLISH ) )
assertTrue ( callerClass . getPackage ( ) . getName ( ) . contains ( "junit" ) , "Oops, didn't get a junit type of class: " + callerClass )
assertNull ( OpenmrsUtil . url2file ( null ) )
assertNull ( OpenmrsUtil . shortenedStackTrace ( null ) , "null value was not returned with null parameter" )
assertFalse ( OpenmrsUtil . isInNormalNumericRange ( 5.67f , concept ) )
assertTrue ( OpenmrsUtil . isInNormalNumericRange ( 5.67f , concept ) )
assertFalse ( OpenmrsUtil . isInNormalNumericRange ( 5.67f , concept ) )
assertFalse ( OpenmrsUtil . isInAbsoluteNumericRange ( 5.67f , concept ) )
assertFalse ( OpenmrsUtil . isInAbsoluteNumericRange ( 5.67f , concept ) )
assertFalse ( OpenmrsUtil . isInAbsoluteNumericRange ( 5.67f , concept ) )
assertFalse ( OpenmrsUtil . isInAbsoluteNumericRange ( 5.67f , concept ) )
assertFalse ( OpenmrsUtil . isInAbsoluteNumericRange ( 4.34f , concept ) )
assertTrue ( OpenmrsUtil . isValidNumericValue ( 5.67f , concept ) )
assertTrue ( OpenmrsUtil . isValidNumericValue ( 5.67f , concept ) )
assertFalse ( OpenmrsUtil . isValidNumericValue ( 5.67f , concept ) )
assertFalse ( OpenmrsUtil . isInAbsoluteNumericRange ( 4.34f , concept ) )
assertFalse ( OpenmrsUtil . isInAbsoluteNumericRange ( 4.34f , concept ) )
assertTrue ( actualValue < 0 , "Expected a negative value but it was: " + actualValue )
assertTrue ( actualValue > 0 , "Expected a positive value but it was: " + actualValue )
assertEquals ( 0 , actualValue )
assertTrue ( actualValue < 0 , "Expected a negative value but it was: " + actualValue )
assertFalse ( fields . contains ( normalClassField ) )
assertThat ( exception . getMessage ( ) , containsString ( errorMsgSubString ) )
assertThat ( exception . getMessage ( ) , containsString ( errorMsgSubString ) )
assertThatFieldTextHasError ( )
assertThatFieldTextHasError ( )
assertThat ( exception . getMessage ( ) , is ( "Allergy should not be null" ) )
assertFalse ( errors . hasFieldErrors ( "memberships" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "code" ) )
assertTrue ( errors . hasFieldErrors ( "code" ) )
assertTrue ( errors . hasFieldErrors ( "conceptSource" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "conceptReferenceTermMaps[0].conceptMapType" ) )
assertTrue ( errors . hasFieldErrors ( "conceptReferenceTermMaps[0].termB" ) )
assertTrue ( errors . hasFieldErrors ( "conceptReferenceTermMaps[0].termB" ) )
assertThat ( exception . getMessage ( ) , is ( "The parameter obj should not be null and must be of type" + Concept . class ) )
assertThat ( exception . getMessage ( ) , is ( "'" + duplicateName + "' is a duplicate name in locale '" + Context . getLocale ( ) + "' for the same concept" ) )
assertThat ( errors , hasGlobalErrors ( "Concept.error.no.FullySpecifiedName" ) )
assertThat ( errors , hasGlobalErrors ( "Concept.contains.itself.as.answer" ) )
assertThat ( errors , not ( hasFieldErrors ( "description" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "description" ) ) )
assertThat ( exception . getMessage ( ) , is ( NULL_ERROR_MESSAGE ) )
assertTrue ( errors . hasFieldErrors ( "encounter" ) )
assertTrue ( errors . hasFieldErrors ( "rank" ) )
assertTrue ( errors . hasFieldErrors ( "asNeeded" ) )
assertFalse ( errors . hasFieldErrors ( "drug" ) )
assertTrue ( errors . hasFieldErrors ( "dose" ) )
assertTrue ( errors . hasFieldErrors ( "doseUnits" ) )
assertTrue ( errors . hasFieldErrors ( "route" ) )
assertTrue ( errors . hasFieldErrors ( "frequency" ) )
assertTrue ( errors . hasFieldErrors ( "quantityUnits" ) )
assertTrue ( errors . hasFieldErrors ( "durationUnits" ) )
assertTrue ( errors . hasFieldErrors ( "concept" ) )
assertTrue ( errors . hasFieldErrors ( "concept" ) )
assertFalse ( errors . hasFieldErrors ( ) )
assertFalse ( errors . hasFieldErrors ( "dosingInstructions" ) )
assertTrue ( errors . hasFieldErrors ( "drugReferenceMaps[0].drug" ) )
assertTrue ( errors . hasFieldErrors ( "drugReferenceMaps[0].conceptMapType.name" ) )
assertFalse ( errors . hasFieldErrors ( ) )
assertFalse ( errors . hasFieldErrors ( ) )
assertTrue ( errors . hasFieldErrors ( "patient" ) )
assertTrue ( errors . hasFieldErrors ( "encounterDatetime" ) )
assertTrue ( errors . hasFieldErrors ( "encounterDatetime" ) )
assertTrue ( errors . hasFieldErrors ( "encounterDatetime" ) )
assertTrue ( errors . hasFieldErrors ( "encounterDatetime" ) )
assertTrue ( errors . hasFieldErrors ( "encounterType" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "retired" ) )
assertTrue ( errors . hasFieldErrors ( "retireReason" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertEquals ( e . getMessage ( ) , Context . getMessageSourceService ( ) . getMessage ( "ImplementationId.null" ) )
assertTrue ( errors . hasFieldErrors ( "retireReason" ) )
assertTrue ( errors . hasFieldErrors ( "parentLocation" ) )
assertTrue ( errors . hasFieldErrors ( "valueText" ) )
assertTrue ( errors . hasFieldErrors ( "valueDrug" ) )
assertFalse ( errors . hasFieldErrors ( ) )
assertTrue ( errors . hasFieldErrors ( "concept" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "encounter" ) )
assertTrue ( errors . hasFieldErrors ( "dateActivated" ) )
assertTrue ( errors . hasFieldErrors ( "action" ) )
assertFalse ( errors . hasFieldErrors ( "orderType" ) )
assertNotNull ( duplicateId . getLocation ( ) )
assertTrue ( errors . hasFieldErrors ( "patient" ) )
assertTrue ( errors . hasFieldErrors ( "states" ) )
assertTrue ( errors . hasFieldErrors ( "states" ) )
assertTrue ( errors . hasFieldErrors ( "states" ) )
assertFalse ( errors . hasFieldErrors ( "states" ) )
assertTrue ( errors . hasFieldErrors ( "dateEnrolled" ) )
assertTrue ( errors . hasFieldErrors ( "dateCompleted" ) )
assertTrue ( errors . hasFieldErrors ( "voidReason" ) )
assertTrue ( errors . hasFieldErrors ( "gender" ) )
assertTrue ( errors . hasFieldErrors ( ) )
assertFalse ( errors . hasFieldErrors ( ) )
assertFalse ( errors . hasFieldErrors ( ) )
assertFalse ( errors . hasFieldErrors ( ) )
assertFalse ( errors . hasFieldErrors ( ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "format" ) )
assertTrue ( errors . hasFieldErrors ( "personMergeLogData" ) )
assertFalse ( errors . hasFieldErrors ( ) )
assertTrue ( errors . hasFieldErrors ( "voidReason" ) )
assertThat ( errors , hasGlobalErrors ( "error.name" ) )
assertThat ( errors , hasFieldErrors ( "givenName" , "Patient.names.required.given.family" ) )
assertThat ( errors , hasFieldErrors ( "givenName" , "Patient.names.required.given.family" ) )
assertThat ( errors , not ( hasFieldErrors ( "givenName" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "familyName" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "familyName" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "familyName" ) ) )
assertThat ( errors , hasFieldErrors ( "prefix" , "error.exceededMaxLengthOfField" ) )
assertThat ( errors , not ( hasFieldErrors ( "prefix" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "prefix" ) ) )
assertThat ( errors , hasFieldErrors ( "givenName" , "error.exceededMaxLengthOfField" ) )
assertThat ( errors , not ( hasFieldErrors ( "givenName" ) ) )
assertThat ( errors , hasFieldErrors ( "middleName" , "error.exceededMaxLengthOfField" ) )
assertThat ( errors , not ( hasFieldErrors ( "middleName" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "middleName" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "familyNamePrefix" ) ) )
assertThat ( errors , hasFieldErrors ( "familyName" , "error.exceededMaxLengthOfField" ) )
assertThat ( errors , not ( hasFieldErrors ( "familyName" ) ) )
assertThat ( errors , hasFieldErrors ( "familyName2" , "error.exceededMaxLengthOfField" ) )
assertThat ( errors , not ( hasFieldErrors ( "familyName2" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "familyName2" ) ) )
assertThat ( errors , hasFieldErrors ( "familyNameSuffix" , "error.exceededMaxLengthOfField" ) )
assertThat ( errors , not ( hasFieldErrors ( "familyNameSuffix" ) ) )
assertThat ( errors , hasFieldErrors ( "degree" , "error.exceededMaxLengthOfField" ) )
assertThat ( errors , not ( hasFieldErrors ( "degree" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "degree" ) ) )
assertThat ( errors , hasFieldErrors ( "givenName" , "GivenName.invalid" ) )
assertThat ( errors , not ( hasFieldErrors ( "givenName" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "middleName" ) ) )
assertThat ( errors , hasFieldErrors ( "familyName" , "FamilyName.invalid" ) )
assertThat ( errors , not ( hasFieldErrors ( "familyName" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "familyName2" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "familyName" ) ) )
assertThat ( errors , not ( hasFieldErrors ( "givenName" ) ) )
assertThat ( errors , hasFieldErrors ( "names[0]." + "givenName" ) )
assertTrue ( errors . hasFieldErrors ( "birthdate" ) )
assertTrue ( errors . hasFieldErrors ( "birthdate" ) )
assertTrue ( errors . hasFieldErrors ( "names" ) )
assertFalse ( errors . hasFieldErrors ( "gender" ) )
assertTrue ( errors . hasFieldErrors ( "deathDate" ) )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertFalse ( errors . hasFieldErrors ( "identifier" ) )
assertTrue ( errors . hasFieldErrors ( "activeAttributes" ) )
assertTrue ( errors . hasFieldErrors ( "activeAttributes" ) )
assertTrue ( errors . hasFieldErrors ( "voidReason" ) )
assertTrue ( errors . hasFieldErrors ( "role" ) )
assertTrue ( errors . hasFieldErrors ( "concept" ) )
assertTrue ( errors . hasFieldErrors ( "programWorkflowState" ) )
assertFalse ( errors . hasFieldErrors ( "username" ) )
assertTrue ( true )
assertTrue ( errors . hasFieldErrors ( "name" ) )
assertTrue ( errors . hasFieldErrors ( "patient" ) )
assertTrue ( errors . hasFieldErrors ( "visitType" ) )
assertTrue ( errors . hasFieldErrors ( "stopDatetime" ) )
assertTrue ( errors . hasFieldErrors ( "startDatetime" ) )
assertTrue ( errors . hasFieldErrors ( "attributes" ) )
assertTrue ( errors . hasFieldErrors ( "stopDatetime" ) )
assertTrue ( errors . hasFieldErrors ( "stopDatetime" ) )
assertFalse ( errors . hasFieldErrors ( "voidReason" ) )
assertTrue ( errors . hasFieldErrors ( "voidReason" ) )
assertTrue ( schemaOnlyTuner . readResource ( FILE_WITH_LICENSE_HEADER_MD ) . contains ( HTTP_OPENMRS_ORG_LICENSE ) )
assertEquals ( "databaseChangeLog" , actual . getName ( ) )
assertThat ( exception . getMessage ( ) , is ( "Unable to parse filters in module configuration." ) )
assertTrue ( f . exists ( ) )
assertEquals ( "" , WebUtil . getContextPath ( ) )
assertEquals ( "" , WebUtil . getContextPath ( ) )
assertNull ( WebUtil . normalizeLocale ( "" ) )
assertEquals ( 0 , cookies . length , "Expected no cookies in response" )
assertTrue ( new UpdateFilter ( ) . isSuperUser ( getConnection ( ) , 1 ) )
